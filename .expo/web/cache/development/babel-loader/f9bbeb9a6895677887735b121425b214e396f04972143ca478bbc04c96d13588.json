{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _AnimatedImplementation = _interopRequireDefault(require(\"../../Animated/AnimatedImplementation\"));\nvar _FrameRateLogger = _interopRequireDefault(require(\"../../Interaction/FrameRateLogger\"));\nvar _RendererProxy = require(\"../../ReactNative/RendererProxy\");\nvar _UIManager = _interopRequireDefault(require(\"../../ReactNative/UIManager\"));\nvar _flattenStyle = _interopRequireDefault(require(\"../../StyleSheet/flattenStyle\"));\nvar _splitLayoutProps2 = _interopRequireDefault(require(\"../../StyleSheet/splitLayoutProps\"));\nvar _StyleSheet = _interopRequireDefault(require(\"../../StyleSheet/StyleSheet\"));\nvar _Dimensions = _interopRequireDefault(require(\"../../Utilities/Dimensions\"));\nvar _dismissKeyboard = _interopRequireDefault(require(\"../../Utilities/dismissKeyboard\"));\nvar _Platform = _interopRequireDefault(require(\"../../Utilities/Platform\"));\nvar _Keyboard = _interopRequireDefault(require(\"../Keyboard/Keyboard\"));\nvar _TextInputState = _interopRequireDefault(require(\"../TextInput/TextInputState\"));\nvar _View = _interopRequireDefault(require(\"../View/View\"));\nvar _AndroidHorizontalScrollContentViewNativeComponent = _interopRequireDefault(require(\"./AndroidHorizontalScrollContentViewNativeComponent\"));\nvar _AndroidHorizontalScrollViewNativeComponent = _interopRequireDefault(require(\"./AndroidHorizontalScrollViewNativeComponent\"));\nvar _processDecelerationRate = _interopRequireDefault(require(\"./processDecelerationRate\"));\nvar _ScrollContentViewNativeComponent = _interopRequireDefault(require(\"./ScrollContentViewNativeComponent\"));\nvar _ScrollViewCommands = _interopRequireDefault(require(\"./ScrollViewCommands\"));\nvar _ScrollViewContext = _interopRequireWildcard(require(\"./ScrollViewContext\"));\nvar _ScrollViewNativeComponent = _interopRequireDefault(require(\"./ScrollViewNativeComponent\"));\nvar _ScrollViewStickyHeader = _interopRequireDefault(require(\"./ScrollViewStickyHeader\"));\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\nvar _memoizeOne = _interopRequireDefault(require(\"memoize-one\"));\nvar _nullthrows = _interopRequireDefault(require(\"nullthrows\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nvar _jsxFileName = \"C:\\\\Users\\\\stjones\\\\Desktop\\\\Ra_App\\\\node_modules\\\\react-native\\\\Libraries\\\\Components\\\\ScrollView\\\\ScrollView.js\";\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nfunction _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nif (_Platform.default.OS === 'ios') {\n  require('../../Renderer/shims/ReactNative');\n}\nvar _ref = _Platform.default.OS === 'android' ? {\n    NativeHorizontalScrollViewTuple: [_AndroidHorizontalScrollViewNativeComponent.default, _AndroidHorizontalScrollContentViewNativeComponent.default],\n    NativeVerticalScrollViewTuple: [_ScrollViewNativeComponent.default, _View.default]\n  } : {\n    NativeHorizontalScrollViewTuple: [_ScrollViewNativeComponent.default, _ScrollContentViewNativeComponent.default],\n    NativeVerticalScrollViewTuple: [_ScrollViewNativeComponent.default, _ScrollContentViewNativeComponent.default]\n  },\n  NativeHorizontalScrollViewTuple = _ref.NativeHorizontalScrollViewTuple,\n  NativeVerticalScrollViewTuple = _ref.NativeVerticalScrollViewTuple;\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollView = function (_React$Component) {\n  function ScrollView(props) {\n    var _this$props$contentOf, _this$props$contentOf2, _this$props$contentIn, _this$props$contentIn2;\n    var _this;\n    (0, _classCallCheck2.default)(this, ScrollView);\n    _this = _callSuper(this, ScrollView, [props]);\n    _this._scrollAnimatedValueAttachment = null;\n    _this._stickyHeaderRefs = new Map();\n    _this._headerLayoutYs = new Map();\n    _this._keyboardMetrics = null;\n    _this._additionalScrollOffset = 0;\n    _this._isTouching = false;\n    _this._lastMomentumScrollBeginTime = 0;\n    _this._lastMomentumScrollEndTime = 0;\n    _this._observedScrollSinceBecomingResponder = false;\n    _this._becameResponderWhileAnimating = false;\n    _this._preventNegativeScrollOffset = null;\n    _this._animated = null;\n    _this._subscriptionKeyboardWillShow = null;\n    _this._subscriptionKeyboardWillHide = null;\n    _this._subscriptionKeyboardDidShow = null;\n    _this._subscriptionKeyboardDidHide = null;\n    _this.state = {\n      layoutHeight: null\n    };\n    _this.getScrollResponder = function () {\n      return _this;\n    };\n    _this.getScrollableNode = function () {\n      return (0, _RendererProxy.findNodeHandle)(_this._scrollView.nativeInstance);\n    };\n    _this.getInnerViewNode = function () {\n      return (0, _RendererProxy.findNodeHandle)(_this._innerView.nativeInstance);\n    };\n    _this.getInnerViewRef = function () {\n      return _this._innerView.nativeInstance;\n    };\n    _this.getNativeScrollRef = function () {\n      return _this._scrollView.nativeInstance;\n    };\n    _this.scrollTo = function (options, deprecatedX, deprecatedAnimated) {\n      var x, y, animated;\n      if (typeof options === 'number') {\n        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' + 'animated: true})` instead.');\n        y = options;\n        x = deprecatedX;\n        animated = deprecatedAnimated;\n      } else if (options) {\n        y = options.y;\n        x = options.x;\n        animated = options.animated;\n      }\n      if (_this._scrollView.nativeInstance == null) {\n        return;\n      }\n      _ScrollViewCommands.default.scrollTo(_this._scrollView.nativeInstance, x || 0, y || 0, animated !== false);\n    };\n    _this.scrollToEnd = function (options) {\n      var animated = (options && options.animated) !== false;\n      if (_this._scrollView.nativeInstance == null) {\n        return;\n      }\n      _ScrollViewCommands.default.scrollToEnd(_this._scrollView.nativeInstance, animated);\n    };\n    _this.flashScrollIndicators = function () {\n      if (_this._scrollView.nativeInstance == null) {\n        return;\n      }\n      _ScrollViewCommands.default.flashScrollIndicators(_this._scrollView.nativeInstance);\n    };\n    _this.scrollResponderScrollNativeHandleToKeyboard = function (nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n      _this._additionalScrollOffset = additionalOffset || 0;\n      _this._preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n      if (_this._innerView.nativeInstance == null) {\n        return;\n      }\n      if (typeof nodeHandle === 'number') {\n        _UIManager.default.measureLayout(nodeHandle, (0, _nullthrows.default)((0, _RendererProxy.findNodeHandle)(_this)), _this._textInputFocusError, _this._inputMeasureAndScrollToKeyboard);\n      } else {\n        nodeHandle.measureLayout(_this._innerView.nativeInstance, _this._inputMeasureAndScrollToKeyboard, _this._textInputFocusError);\n      }\n    };\n    _this.scrollResponderZoomTo = function (rect, animated) {\n      (0, _invariant.default)(_Platform.default.OS === 'ios', 'zoomToRect is not implemented');\n      if ('animated' in rect) {\n        _this._animated = rect.animated;\n        delete rect.animated;\n      } else if (typeof animated !== 'undefined') {\n        console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');\n      }\n      if (_this._scrollView.nativeInstance == null) {\n        return;\n      }\n      _ScrollViewCommands.default.zoomToRect(_this._scrollView.nativeInstance, rect, animated !== false);\n    };\n    _this._inputMeasureAndScrollToKeyboard = function (left, top, width, height) {\n      var keyboardScreenY = _Dimensions.default.get('window').height;\n      var scrollTextInputIntoVisibleRect = function scrollTextInputIntoVisibleRect() {\n        if (_this._keyboardMetrics != null) {\n          keyboardScreenY = _this._keyboardMetrics.screenY;\n        }\n        var scrollOffsetY = top - keyboardScreenY + height + _this._additionalScrollOffset;\n        if (_this._preventNegativeScrollOffset === true) {\n          scrollOffsetY = Math.max(0, scrollOffsetY);\n        }\n        _this.scrollTo({\n          x: 0,\n          y: scrollOffsetY,\n          animated: true\n        });\n        _this._additionalScrollOffset = 0;\n        _this._preventNegativeScrollOffset = false;\n      };\n      if (_this._keyboardMetrics == null) {\n        setTimeout(function () {\n          scrollTextInputIntoVisibleRect();\n        }, 0);\n      } else {\n        scrollTextInputIntoVisibleRect();\n      }\n    };\n    _this._handleScroll = function (e) {\n      if (__DEV__) {\n        if (_this.props.onScroll && _this.props.scrollEventThrottle == null && _Platform.default.OS === 'ios') {\n          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + \"cause frame drops, use a bigger number if you don't need as \" + 'much precision.');\n        }\n      }\n      _this._observedScrollSinceBecomingResponder = true;\n      _this.props.onScroll && _this.props.onScroll(e);\n    };\n    _this._handleLayout = function (e) {\n      if (_this.props.invertStickyHeaders === true) {\n        _this.setState({\n          layoutHeight: e.nativeEvent.layout.height\n        });\n      }\n      if (_this.props.onLayout) {\n        _this.props.onLayout(e);\n      }\n    };\n    _this._handleContentOnLayout = function (e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        width = _e$nativeEvent$layout.width,\n        height = _e$nativeEvent$layout.height;\n      _this.props.onContentSizeChange && _this.props.onContentSizeChange(width, height);\n    };\n    _this._innerView = createRefForwarder(function (instance) {\n      return instance;\n    });\n    _this._scrollView = createRefForwarder(function (nativeInstance) {\n      var publicInstance = Object.assign(nativeInstance, {\n        getScrollResponder: _this.getScrollResponder,\n        getScrollableNode: _this.getScrollableNode,\n        getInnerViewNode: _this.getInnerViewNode,\n        getInnerViewRef: _this.getInnerViewRef,\n        getNativeScrollRef: _this.getNativeScrollRef,\n        scrollTo: _this.scrollTo,\n        scrollToEnd: _this.scrollToEnd,\n        flashScrollIndicators: _this.flashScrollIndicators,\n        scrollResponderZoomTo: _this.scrollResponderZoomTo,\n        scrollResponderScrollNativeHandleToKeyboard: _this.scrollResponderScrollNativeHandleToKeyboard\n      });\n      return publicInstance;\n    });\n    _this.scrollResponderKeyboardWillShow = function (e) {\n      _this._keyboardMetrics = e.endCoordinates;\n      _this.props.onKeyboardWillShow && _this.props.onKeyboardWillShow(e);\n    };\n    _this.scrollResponderKeyboardWillHide = function (e) {\n      _this._keyboardMetrics = null;\n      _this.props.onKeyboardWillHide && _this.props.onKeyboardWillHide(e);\n    };\n    _this.scrollResponderKeyboardDidShow = function (e) {\n      _this._keyboardMetrics = e.endCoordinates;\n      _this.props.onKeyboardDidShow && _this.props.onKeyboardDidShow(e);\n    };\n    _this.scrollResponderKeyboardDidHide = function (e) {\n      _this._keyboardMetrics = null;\n      _this.props.onKeyboardDidHide && _this.props.onKeyboardDidHide(e);\n    };\n    _this._handleMomentumScrollBegin = function (e) {\n      _this._lastMomentumScrollBeginTime = global.performance.now();\n      _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);\n    };\n    _this._handleMomentumScrollEnd = function (e) {\n      _FrameRateLogger.default.endScroll();\n      _this._lastMomentumScrollEndTime = global.performance.now();\n      _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);\n    };\n    _this._handleScrollBeginDrag = function (e) {\n      _FrameRateLogger.default.beginScroll();\n      if (_Platform.default.OS === 'android' && _this.props.keyboardDismissMode === 'on-drag') {\n        (0, _dismissKeyboard.default)();\n      }\n      _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);\n    };\n    _this._handleScrollEndDrag = function (e) {\n      var velocity = e.nativeEvent.velocity;\n      if (!_this._isAnimating() && (!velocity || velocity.x === 0 && velocity.y === 0)) {\n        _FrameRateLogger.default.endScroll();\n      }\n      _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);\n    };\n    _this._isAnimating = function () {\n      var now = global.performance.now();\n      var timeSinceLastMomentumScrollEnd = now - _this._lastMomentumScrollEndTime;\n      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || _this._lastMomentumScrollEndTime < _this._lastMomentumScrollBeginTime;\n      return isAnimating;\n    };\n    _this._handleResponderGrant = function (e) {\n      _this._observedScrollSinceBecomingResponder = false;\n      _this.props.onResponderGrant && _this.props.onResponderGrant(e);\n      _this._becameResponderWhileAnimating = _this._isAnimating();\n    };\n    _this._handleResponderReject = function () {};\n    _this._handleResponderRelease = function (e) {\n      _this._isTouching = e.nativeEvent.touches.length !== 0;\n      _this.props.onResponderRelease && _this.props.onResponderRelease(e);\n      if (typeof e.target === 'number') {\n        if (__DEV__) {\n          console.error('Did not expect event target to be a number. Should have been a native component');\n        }\n        return;\n      }\n      var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedInput();\n      if (currentlyFocusedTextInput != null && _this.props.keyboardShouldPersistTaps !== true && _this.props.keyboardShouldPersistTaps !== 'always' && _this._keyboardIsDismissible() && e.target !== currentlyFocusedTextInput && !_this._observedScrollSinceBecomingResponder && !_this._becameResponderWhileAnimating) {\n        _TextInputState.default.blurTextInput(currentlyFocusedTextInput);\n      }\n    };\n    _this._handleResponderTerminationRequest = function () {\n      return !_this._observedScrollSinceBecomingResponder;\n    };\n    _this._handleScrollShouldSetResponder = function () {\n      if (_this.props.disableScrollViewPanResponder === true) {\n        return false;\n      }\n      return _this._isTouching;\n    };\n    _this._handleStartShouldSetResponder = function (e) {\n      if (_this.props.disableScrollViewPanResponder === true) {\n        return false;\n      }\n      var currentlyFocusedInput = _TextInputState.default.currentlyFocusedInput();\n      if (_this.props.keyboardShouldPersistTaps === 'handled' && _this._keyboardIsDismissible() && e.target !== currentlyFocusedInput) {\n        return true;\n      }\n      return false;\n    };\n    _this._handleStartShouldSetResponderCapture = function (e) {\n      if (_this._isAnimating()) {\n        return true;\n      }\n      if (_this.props.disableScrollViewPanResponder === true) {\n        return false;\n      }\n      var keyboardShouldPersistTaps = _this.props.keyboardShouldPersistTaps;\n      var keyboardNeverPersistTaps = !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n      if (typeof e.target === 'number') {\n        if (__DEV__) {\n          console.error('Did not expect event target to be a number. Should have been a native component');\n        }\n        return false;\n      }\n      if (_this._softKeyboardIsDetached()) {\n        return false;\n      }\n      if (keyboardNeverPersistTaps && _this._keyboardIsDismissible() && e.target != null && !_TextInputState.default.isTextInput(e.target)) {\n        return true;\n      }\n      return false;\n    };\n    _this._keyboardIsDismissible = function () {\n      var currentlyFocusedInput = _TextInputState.default.currentlyFocusedInput();\n      var hasFocusedTextInput = currentlyFocusedInput != null && _TextInputState.default.isTextInput(currentlyFocusedInput);\n      var softKeyboardMayBeOpen = _this._keyboardMetrics != null || _this._keyboardEventsAreUnreliable();\n      return hasFocusedTextInput && softKeyboardMayBeOpen;\n    };\n    _this._softKeyboardIsDetached = function () {\n      return _this._keyboardMetrics != null && _this._keyboardMetrics.height === 0;\n    };\n    _this._keyboardEventsAreUnreliable = function () {\n      return _Platform.default.OS === 'android' && _Platform.default.Version < 30;\n    };\n    _this._handleTouchEnd = function (e) {\n      var nativeEvent = e.nativeEvent;\n      _this._isTouching = nativeEvent.touches.length !== 0;\n      var keyboardShouldPersistTaps = _this.props.keyboardShouldPersistTaps;\n      var keyboardNeverPersistsTaps = !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n      var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedInput();\n      if (currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && _this._softKeyboardIsDetached() && _this._keyboardIsDismissible() && keyboardNeverPersistsTaps) {\n        _TextInputState.default.blurTextInput(currentlyFocusedTextInput);\n      }\n      _this.props.onTouchEnd && _this.props.onTouchEnd(e);\n    };\n    _this._handleTouchCancel = function (e) {\n      _this._isTouching = false;\n      _this.props.onTouchCancel && _this.props.onTouchCancel(e);\n    };\n    _this._handleTouchStart = function (e) {\n      _this._isTouching = true;\n      _this.props.onTouchStart && _this.props.onTouchStart(e);\n    };\n    _this._handleTouchMove = function (e) {\n      _this.props.onTouchMove && _this.props.onTouchMove(e);\n    };\n    _this._scrollAnimatedValue = new _AnimatedImplementation.default.Value((_this$props$contentOf = (_this$props$contentOf2 = _this.props.contentOffset) == null ? void 0 : _this$props$contentOf2.y) != null ? _this$props$contentOf : 0);\n    _this._scrollAnimatedValue.setOffset((_this$props$contentIn = (_this$props$contentIn2 = _this.props.contentInset) == null ? void 0 : _this$props$contentIn2.top) != null ? _this$props$contentIn : 0);\n    return _this;\n  }\n  (0, _inherits2.default)(ScrollView, _React$Component);\n  return (0, _createClass2.default)(ScrollView, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (typeof this.props.keyboardShouldPersistTaps === 'boolean') {\n        console.warn(`'keyboardShouldPersistTaps={${this.props.keyboardShouldPersistTaps === true ? 'true' : 'false'}}' is deprecated. ` + `Use 'keyboardShouldPersistTaps=\"${this.props.keyboardShouldPersistTaps ? 'always' : 'never'}\"' instead`);\n      }\n      this._keyboardMetrics = _Keyboard.default.metrics();\n      this._additionalScrollOffset = 0;\n      this._subscriptionKeyboardWillShow = _Keyboard.default.addListener('keyboardWillShow', this.scrollResponderKeyboardWillShow);\n      this._subscriptionKeyboardWillHide = _Keyboard.default.addListener('keyboardWillHide', this.scrollResponderKeyboardWillHide);\n      this._subscriptionKeyboardDidShow = _Keyboard.default.addListener('keyboardDidShow', this.scrollResponderKeyboardDidShow);\n      this._subscriptionKeyboardDidHide = _Keyboard.default.addListener('keyboardDidHide', this.scrollResponderKeyboardDidHide);\n      this._updateAnimatedNodeAttachment();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevContentInsetTop = prevProps.contentInset ? prevProps.contentInset.top : 0;\n      var newContentInsetTop = this.props.contentInset ? this.props.contentInset.top : 0;\n      if (prevContentInsetTop !== newContentInsetTop) {\n        this._scrollAnimatedValue.setOffset(newContentInsetTop || 0);\n      }\n      this._updateAnimatedNodeAttachment();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._subscriptionKeyboardWillShow != null) {\n        this._subscriptionKeyboardWillShow.remove();\n      }\n      if (this._subscriptionKeyboardWillHide != null) {\n        this._subscriptionKeyboardWillHide.remove();\n      }\n      if (this._subscriptionKeyboardDidShow != null) {\n        this._subscriptionKeyboardDidShow.remove();\n      }\n      if (this._subscriptionKeyboardDidHide != null) {\n        this._subscriptionKeyboardDidHide.remove();\n      }\n      if (this._scrollAnimatedValueAttachment) {\n        this._scrollAnimatedValueAttachment.detach();\n      }\n    }\n  }, {\n    key: \"_textInputFocusError\",\n    value: function _textInputFocusError() {\n      console.warn('Error measuring text field.');\n    }\n  }, {\n    key: \"_getKeyForIndex\",\n    value: function _getKeyForIndex(index, childArray) {\n      var child = childArray[index];\n      return child && child.key;\n    }\n  }, {\n    key: \"_updateAnimatedNodeAttachment\",\n    value: function _updateAnimatedNodeAttachment() {\n      if (this._scrollAnimatedValueAttachment) {\n        this._scrollAnimatedValueAttachment.detach();\n      }\n      if (this.props.stickyHeaderIndices && this.props.stickyHeaderIndices.length > 0) {\n        this._scrollAnimatedValueAttachment = _AnimatedImplementation.default.attachNativeEvent(this._scrollView.nativeInstance, 'onScroll', [{\n          nativeEvent: {\n            contentOffset: {\n              y: this._scrollAnimatedValue\n            }\n          }\n        }]);\n      }\n    }\n  }, {\n    key: \"_setStickyHeaderRef\",\n    value: function _setStickyHeaderRef(key, ref) {\n      if (ref) {\n        this._stickyHeaderRefs.set(key, ref);\n      } else {\n        this._stickyHeaderRefs.delete(key);\n      }\n    }\n  }, {\n    key: \"_onStickyHeaderLayout\",\n    value: function _onStickyHeaderLayout(index, event, key) {\n      var stickyHeaderIndices = this.props.stickyHeaderIndices;\n      if (!stickyHeaderIndices) {\n        return;\n      }\n      var childArray = React.Children.toArray(this.props.children);\n      if (key !== this._getKeyForIndex(index, childArray)) {\n        return;\n      }\n      var layoutY = event.nativeEvent.layout.y;\n      this._headerLayoutYs.set(key, layoutY);\n      var indexOfIndex = stickyHeaderIndices.indexOf(index);\n      var previousHeaderIndex = stickyHeaderIndices[indexOfIndex - 1];\n      if (previousHeaderIndex != null) {\n        var previousHeader = this._stickyHeaderRefs.get(this._getKeyForIndex(previousHeaderIndex, childArray));\n        previousHeader && previousHeader.setNextHeaderY && previousHeader.setNextHeaderY(layoutY);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _ref2 = this.props.horizontal === true ? NativeHorizontalScrollViewTuple : NativeVerticalScrollViewTuple,\n        _ref3 = (0, _slicedToArray2.default)(_ref2, 2),\n        NativeDirectionalScrollView = _ref3[0],\n        NativeDirectionalScrollContentView = _ref3[1];\n      var contentContainerStyle = [this.props.horizontal === true && styles.contentContainerHorizontal, this.props.contentContainerStyle];\n      if (__DEV__ && this.props.style !== undefined) {\n        var style = (0, _flattenStyle.default)(this.props.style);\n        var childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {\n          return style && style[prop] !== undefined;\n        });\n        (0, _invariant.default)(childLayoutProps.length === 0, 'ScrollView child layout (' + JSON.stringify(childLayoutProps) + ') must be applied through the contentContainerStyle prop.');\n      }\n      var contentSizeChangeProps = this.props.onContentSizeChange == null ? null : {\n        onLayout: this._handleContentOnLayout\n      };\n      var stickyHeaderIndices = this.props.stickyHeaderIndices;\n      var children = this.props.children;\n      if (stickyHeaderIndices != null && stickyHeaderIndices.length > 0) {\n        var childArray = React.Children.toArray(this.props.children);\n        children = childArray.map(function (child, index) {\n          var indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;\n          if (indexOfIndex > -1) {\n            var key = child.key;\n            var nextIndex = stickyHeaderIndices[indexOfIndex + 1];\n            var StickyHeaderComponent = _this2.props.StickyHeaderComponent || _ScrollViewStickyHeader.default;\n            return (0, _jsxRuntime.jsx)(StickyHeaderComponent, {\n              nativeID: 'StickyHeader-' + key,\n              ref: function ref(_ref4) {\n                return _this2._setStickyHeaderRef(key, _ref4);\n              },\n              nextHeaderLayoutY: _this2._headerLayoutYs.get(_this2._getKeyForIndex(nextIndex, childArray)),\n              onLayout: function onLayout(event) {\n                return _this2._onStickyHeaderLayout(index, event, key);\n              },\n              scrollAnimatedValue: _this2._scrollAnimatedValue,\n              inverted: _this2.props.invertStickyHeaders,\n              hiddenOnScroll: _this2.props.stickyHeaderHiddenOnScroll,\n              scrollViewHeight: _this2.state.layoutHeight,\n              children: child\n            }, key);\n          } else {\n            return child;\n          }\n        });\n      }\n      children = (0, _jsxRuntime.jsx)(_ScrollViewContext.default.Provider, {\n        value: this.props.horizontal === true ? _ScrollViewContext.HORIZONTAL : _ScrollViewContext.VERTICAL,\n        children: children\n      });\n      var hasStickyHeaders = Array.isArray(stickyHeaderIndices) && stickyHeaderIndices.length > 0;\n      var contentContainer = (0, _jsxRuntime.jsx)(NativeDirectionalScrollContentView, Object.assign({}, contentSizeChangeProps, {\n        ref: this._innerView.getForwardingRef(this.props.innerViewRef),\n        style: contentContainerStyle,\n        removeClippedSubviews: _Platform.default.OS === 'android' && hasStickyHeaders ? false : this.props.removeClippedSubviews,\n        collapsable: false,\n        children: children\n      }));\n      var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;\n      var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;\n      var baseStyle = this.props.horizontal === true ? styles.baseHorizontal : styles.baseVertical;\n      var props = Object.assign({}, this.props, {\n        alwaysBounceHorizontal: alwaysBounceHorizontal,\n        alwaysBounceVertical: alwaysBounceVertical,\n        style: _StyleSheet.default.compose(baseStyle, this.props.style),\n        onContentSizeChange: null,\n        onLayout: this._handleLayout,\n        onMomentumScrollBegin: this._handleMomentumScrollBegin,\n        onMomentumScrollEnd: this._handleMomentumScrollEnd,\n        onResponderGrant: this._handleResponderGrant,\n        onResponderReject: this._handleResponderReject,\n        onResponderRelease: this._handleResponderRelease,\n        onResponderTerminationRequest: this._handleResponderTerminationRequest,\n        onScrollBeginDrag: this._handleScrollBeginDrag,\n        onScrollEndDrag: this._handleScrollEndDrag,\n        onScrollShouldSetResponder: this._handleScrollShouldSetResponder,\n        onStartShouldSetResponder: this._handleStartShouldSetResponder,\n        onStartShouldSetResponderCapture: this._handleStartShouldSetResponderCapture,\n        onTouchEnd: this._handleTouchEnd,\n        onTouchMove: this._handleTouchMove,\n        onTouchStart: this._handleTouchStart,\n        onTouchCancel: this._handleTouchCancel,\n        onScroll: this._handleScroll,\n        scrollEventThrottle: hasStickyHeaders ? 1 : this.props.scrollEventThrottle,\n        sendMomentumEvents: this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd ? true : false,\n        snapToStart: this.props.snapToStart !== false,\n        snapToEnd: this.props.snapToEnd !== false,\n        pagingEnabled: _Platform.default.select({\n          ios: this.props.pagingEnabled === true && this.props.snapToInterval == null && this.props.snapToOffsets == null,\n          android: this.props.pagingEnabled === true || this.props.snapToInterval != null || this.props.snapToOffsets != null\n        })\n      });\n      var decelerationRate = this.props.decelerationRate;\n      if (decelerationRate != null) {\n        props.decelerationRate = (0, _processDecelerationRate.default)(decelerationRate);\n      }\n      var refreshControl = this.props.refreshControl;\n      var scrollViewRef = this._scrollView.getForwardingRef(this.props.scrollViewRef);\n      if (refreshControl) {\n        if (_Platform.default.OS === 'ios') {\n          return (0, _jsxRuntime.jsxs)(NativeDirectionalScrollView, Object.assign({}, props, {\n            ref: scrollViewRef,\n            children: [refreshControl, contentContainer]\n          }));\n        } else if (_Platform.default.OS === 'android') {\n          var _splitLayoutProps = (0, _splitLayoutProps2.default)((0, _flattenStyle.default)(props.style)),\n            outer = _splitLayoutProps.outer,\n            inner = _splitLayoutProps.inner;\n          return React.cloneElement(refreshControl, {\n            style: _StyleSheet.default.compose(baseStyle, outer)\n          }, (0, _jsxRuntime.jsx)(NativeDirectionalScrollView, Object.assign({}, props, {\n            style: _StyleSheet.default.compose(baseStyle, inner),\n            ref: scrollViewRef,\n            children: contentContainer\n          })));\n        }\n      }\n      return (0, _jsxRuntime.jsx)(NativeDirectionalScrollView, Object.assign({}, props, {\n        ref: scrollViewRef,\n        children: contentContainer\n      }));\n    }\n  }]);\n}(React.Component);\nScrollView.Context = _ScrollViewContext.default;\nvar styles = _StyleSheet.default.create({\n  baseVertical: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'column',\n    overflow: 'scroll'\n  },\n  baseHorizontal: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'row',\n    overflow: 'scroll'\n  },\n  contentContainerHorizontal: {\n    flexDirection: 'row'\n  }\n});\nfunction createRefForwarder(mutator) {\n  var state = {\n    getForwardingRef: (0, _memoizeOne.default)(function (forwardedRef) {\n      return function (nativeInstance) {\n        var publicInstance = nativeInstance == null ? null : mutator(nativeInstance);\n        state.nativeInstance = nativeInstance;\n        state.publicInstance = publicInstance;\n        if (forwardedRef != null) {\n          if (typeof forwardedRef === 'function') {\n            forwardedRef(publicInstance);\n          } else {\n            forwardedRef.current = publicInstance;\n          }\n        }\n      };\n    }),\n    nativeInstance: null,\n    publicInstance: null\n  };\n  return state;\n}\nfunction Wrapper(props, ref) {\n  return (0, _jsxRuntime.jsx)(ScrollView, Object.assign({}, props, {\n    scrollViewRef: ref\n  }));\n}\nWrapper.displayName = 'ScrollView';\nvar ForwardedScrollView = React.forwardRef(Wrapper);\nForwardedScrollView.Context = _ScrollViewContext.default;\nForwardedScrollView.displayName = 'ScrollView';\nmodule.exports = ForwardedScrollView;","map":{"version":3,"names":["_AnimatedImplementation","_interopRequireDefault","require","_FrameRateLogger","_RendererProxy","_UIManager","_flattenStyle","_splitLayoutProps2","_StyleSheet","_Dimensions","_dismissKeyboard","_Platform","_Keyboard","_TextInputState","_View","_AndroidHorizontalScrollContentViewNativeComponent","_AndroidHorizontalScrollViewNativeComponent","_processDecelerationRate","_ScrollContentViewNativeComponent","_ScrollViewCommands","_ScrollViewContext","_interopRequireWildcard","_ScrollViewNativeComponent","_ScrollViewStickyHeader","_invariant","_memoizeOne","_nullthrows","React","_jsxRuntime","_jsxFileName","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_callSuper","_getPrototypeOf2","_possibleConstructorReturn2","_isNativeReflectConstruct","Reflect","construct","constructor","apply","Boolean","prototype","valueOf","Platform","OS","_ref","NativeHorizontalScrollViewTuple","AndroidHorizontalScrollViewNativeComponent","AndroidHorizontalScrollContentViewNativeComponent","NativeVerticalScrollViewTuple","ScrollViewNativeComponent","View","ScrollContentViewNativeComponent","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollView","_React$Component","props","_this$props$contentOf","_this$props$contentOf2","_this$props$contentIn","_this$props$contentIn2","_this","_classCallCheck2","_scrollAnimatedValueAttachment","_stickyHeaderRefs","Map","_headerLayoutYs","_keyboardMetrics","_additionalScrollOffset","_isTouching","_lastMomentumScrollBeginTime","_lastMomentumScrollEndTime","_observedScrollSinceBecomingResponder","_becameResponderWhileAnimating","_preventNegativeScrollOffset","_animated","_subscriptionKeyboardWillShow","_subscriptionKeyboardWillHide","_subscriptionKeyboardDidShow","_subscriptionKeyboardDidHide","state","layoutHeight","getScrollResponder","getScrollableNode","findNodeHandle","_scrollView","nativeInstance","getInnerViewNode","_innerView","getInnerViewRef","getNativeScrollRef","scrollTo","options","deprecatedX","deprecatedAnimated","x","y","animated","console","warn","Commands","scrollToEnd","flashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","UIManager","measureLayout","nullthrows","_textInputFocusError","_inputMeasureAndScrollToKeyboard","scrollResponderZoomTo","rect","invariant","zoomToRect","left","top","width","height","keyboardScreenY","Dimensions","scrollTextInputIntoVisibleRect","screenY","scrollOffsetY","Math","max","setTimeout","_handleScroll","__DEV__","onScroll","scrollEventThrottle","log","_handleLayout","invertStickyHeaders","setState","nativeEvent","layout","onLayout","_handleContentOnLayout","_e$nativeEvent$layout","onContentSizeChange","createRefForwarder","instance","publicInstance","assign","scrollResponderKeyboardWillShow","endCoordinates","onKeyboardWillShow","scrollResponderKeyboardWillHide","onKeyboardWillHide","scrollResponderKeyboardDidShow","onKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardDidHide","_handleMomentumScrollBegin","global","performance","now","onMomentumScrollBegin","_handleMomentumScrollEnd","FrameRateLogger","endScroll","onMomentumScrollEnd","_handleScrollBeginDrag","beginScroll","keyboardDismissMode","dismissKeyboard","onScrollBeginDrag","_handleScrollEndDrag","velocity","_isAnimating","onScrollEndDrag","timeSinceLastMomentumScrollEnd","isAnimating","_handleResponderGrant","onResponderGrant","_handleResponderReject","_handleResponderRelease","touches","length","onResponderRelease","target","error","currentlyFocusedTextInput","TextInputState","currentlyFocusedInput","keyboardShouldPersistTaps","_keyboardIsDismissible","blurTextInput","_handleResponderTerminationRequest","_handleScrollShouldSetResponder","disableScrollViewPanResponder","_handleStartShouldSetResponder","_handleStartShouldSetResponderCapture","keyboardNeverPersistTaps","_softKeyboardIsDetached","isTextInput","hasFocusedTextInput","softKeyboardMayBeOpen","_keyboardEventsAreUnreliable","Version","_handleTouchEnd","keyboardNeverPersistsTaps","onTouchEnd","_handleTouchCancel","onTouchCancel","_handleTouchStart","onTouchStart","_handleTouchMove","onTouchMove","_scrollAnimatedValue","AnimatedImplementation","Value","contentOffset","setOffset","contentInset","_inherits2","_createClass2","key","value","componentDidMount","Keyboard","metrics","addListener","_updateAnimatedNodeAttachment","componentDidUpdate","prevProps","prevContentInsetTop","newContentInsetTop","componentWillUnmount","remove","detach","_getKeyForIndex","index","childArray","child","stickyHeaderIndices","attachNativeEvent","_setStickyHeaderRef","ref","delete","_onStickyHeaderLayout","event","Children","toArray","children","layoutY","indexOfIndex","indexOf","previousHeaderIndex","previousHeader","setNextHeaderY","render","_this2","_ref2","horizontal","_ref3","_slicedToArray2","NativeDirectionalScrollView","NativeDirectionalScrollContentView","contentContainerStyle","styles","contentContainerHorizontal","style","undefined","flattenStyle","childLayoutProps","filter","prop","JSON","stringify","contentSizeChangeProps","map","nextIndex","StickyHeaderComponent","ScrollViewStickyHeader","jsx","nativeID","nextHeaderLayoutY","scrollAnimatedValue","inverted","hiddenOnScroll","stickyHeaderHiddenOnScroll","scrollViewHeight","Provider","HORIZONTAL","VERTICAL","hasStickyHeaders","Array","isArray","contentContainer","getForwardingRef","innerViewRef","removeClippedSubviews","collapsable","alwaysBounceHorizontal","alwaysBounceVertical","baseStyle","baseHorizontal","baseVertical","StyleSheet","compose","onResponderReject","onResponderTerminationRequest","onScrollShouldSetResponder","onStartShouldSetResponder","onStartShouldSetResponderCapture","sendMomentumEvents","snapToStart","snapToEnd","pagingEnabled","select","ios","snapToInterval","snapToOffsets","android","decelerationRate","processDecelerationRate","refreshControl","scrollViewRef","jsxs","_splitLayoutProps","splitLayoutProps","outer","inner","cloneElement","Component","Context","ScrollViewContext","create","flexGrow","flexShrink","flexDirection","overflow","mutator","memoize","forwardedRef","current","Wrapper","displayName","ForwardedScrollView","forwardRef","module","exports"],"sources":["C:/Users/stjones/Desktop/Ra_App/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\nimport type {HostComponent} from '../../Renderer/shims/ReactNativeTypes';\nimport type {EdgeInsetsProp} from '../../StyleSheet/EdgeInsetsPropType';\nimport type {PointProp} from '../../StyleSheet/PointPropType';\nimport type {ViewStyleProp} from '../../StyleSheet/StyleSheet';\nimport type {ColorValue} from '../../StyleSheet/StyleSheet';\nimport type {\n  LayoutEvent,\n  PressEvent,\n  ScrollEvent,\n} from '../../Types/CoreEventTypes';\nimport type {EventSubscription} from '../../vendor/emitter/EventEmitter';\nimport type {KeyboardEvent, KeyboardMetrics} from '../Keyboard/Keyboard';\nimport type {ViewProps} from '../View/ViewPropTypes';\nimport type {Props as ScrollViewStickyHeaderProps} from './ScrollViewStickyHeader';\n\nimport AnimatedImplementation from '../../Animated/AnimatedImplementation';\nimport FrameRateLogger from '../../Interaction/FrameRateLogger';\nimport {findNodeHandle} from '../../ReactNative/RendererProxy';\nimport UIManager from '../../ReactNative/UIManager';\nimport flattenStyle from '../../StyleSheet/flattenStyle';\nimport splitLayoutProps from '../../StyleSheet/splitLayoutProps';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Dimensions from '../../Utilities/Dimensions';\nimport dismissKeyboard from '../../Utilities/dismissKeyboard';\nimport Platform from '../../Utilities/Platform';\nimport Keyboard from '../Keyboard/Keyboard';\nimport TextInputState from '../TextInput/TextInputState';\nimport View from '../View/View';\nimport AndroidHorizontalScrollContentViewNativeComponent from './AndroidHorizontalScrollContentViewNativeComponent';\nimport AndroidHorizontalScrollViewNativeComponent from './AndroidHorizontalScrollViewNativeComponent';\nimport processDecelerationRate from './processDecelerationRate';\nimport ScrollContentViewNativeComponent from './ScrollContentViewNativeComponent';\nimport Commands from './ScrollViewCommands';\nimport ScrollViewContext, {HORIZONTAL, VERTICAL} from './ScrollViewContext';\nimport ScrollViewNativeComponent from './ScrollViewNativeComponent';\nimport ScrollViewStickyHeader from './ScrollViewStickyHeader';\nimport invariant from 'invariant';\nimport memoize from 'memoize-one';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\n\nif (Platform.OS === 'ios') {\n  require('../../Renderer/shims/ReactNative'); // Force side effects to prevent T55744311\n}\n\nconst {NativeHorizontalScrollViewTuple, NativeVerticalScrollViewTuple} =\n  Platform.OS === 'android'\n    ? {\n        NativeHorizontalScrollViewTuple: [\n          AndroidHorizontalScrollViewNativeComponent,\n          AndroidHorizontalScrollContentViewNativeComponent,\n        ],\n        NativeVerticalScrollViewTuple: [ScrollViewNativeComponent, View],\n      }\n    : {\n        NativeHorizontalScrollViewTuple: [\n          ScrollViewNativeComponent,\n          ScrollContentViewNativeComponent,\n        ],\n        NativeVerticalScrollViewTuple: [\n          ScrollViewNativeComponent,\n          ScrollContentViewNativeComponent,\n        ],\n      };\n\n/*\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollView` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. This is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\n// Public methods for ScrollView\nexport type ScrollViewImperativeMethods = $ReadOnly<{|\n  getScrollResponder: $PropertyType<ScrollView, 'getScrollResponder'>,\n  getScrollableNode: $PropertyType<ScrollView, 'getScrollableNode'>,\n  getInnerViewNode: $PropertyType<ScrollView, 'getInnerViewNode'>,\n  getInnerViewRef: $PropertyType<ScrollView, 'getInnerViewRef'>,\n  getNativeScrollRef: $PropertyType<ScrollView, 'getNativeScrollRef'>,\n  scrollTo: $PropertyType<ScrollView, 'scrollTo'>,\n  scrollToEnd: $PropertyType<ScrollView, 'scrollToEnd'>,\n  flashScrollIndicators: $PropertyType<ScrollView, 'flashScrollIndicators'>,\n  scrollResponderZoomTo: $PropertyType<ScrollView, 'scrollResponderZoomTo'>,\n  scrollResponderScrollNativeHandleToKeyboard: $PropertyType<\n    ScrollView,\n    'scrollResponderScrollNativeHandleToKeyboard',\n  >,\n|}>;\n\nexport type DecelerationRateType = 'fast' | 'normal' | number;\nexport type ScrollResponderType = ScrollViewImperativeMethods;\n\ntype NativeScrollViewInstance = React.ElementRef<HostComponent<mixed>>;\ntype PublicScrollViewInstance = $ReadOnly<{|\n  ...$Exact<NativeScrollViewInstance>,\n  ...ScrollViewImperativeMethods,\n|}>;\n\ntype InnerViewInstance = React.ElementRef<typeof View>;\n\ntype IOSProps = $ReadOnly<{|\n  /**\n   * Controls whether iOS should automatically adjust the content inset\n   * for scroll views that are placed behind a navigation bar or\n   * tab bar/ toolbar. The default value is true.\n   * @platform ios\n   */\n  automaticallyAdjustContentInsets?: ?boolean,\n  /**\n   * Controls whether the ScrollView should automatically adjust its `contentInset`\n   * and `scrollViewInsets` when the Keyboard changes its size. The default value is false.\n   * @platform ios\n   */\n  automaticallyAdjustKeyboardInsets?: ?boolean,\n  /**\n   * Controls whether iOS should automatically adjust the scroll indicator\n   * insets. The default value is true. Available on iOS 13 and later.\n   * @platform ios\n   */\n  automaticallyAdjustsScrollIndicatorInsets?: ?boolean,\n  /**\n   * The amount by which the scroll view content is inset from the edges\n   * of the scroll view. Defaults to `{top: 0, left: 0, bottom: 0, right: 0}`.\n   * @platform ios\n   */\n  contentInset?: ?EdgeInsetsProp,\n  /**\n   * When true, the scroll view bounces when it reaches the end of the\n   * content if the content is larger then the scroll view along the axis of\n   * the scroll direction. When false, it disables all bouncing even if\n   * the `alwaysBounce*` props are true. The default value is true.\n   * @platform ios\n   */\n  bounces?: ?boolean,\n  /**\n   * By default, ScrollView has an active pan responder that hijacks panresponders\n   * deeper in the render tree in order to prevent accidental touches while scrolling.\n   * However, in certain occasions (such as when using snapToInterval) in a vertical scrollview\n   * You may want to disable this behavior in order to prevent the ScrollView from blocking touches\n   */\n  disableScrollViewPanResponder?: ?boolean,\n  /**\n   * When true, gestures can drive zoom past min/max and the zoom will animate\n   * to the min/max value at gesture end, otherwise the zoom will not exceed\n   * the limits.\n   * @platform ios\n   */\n  bouncesZoom?: ?boolean,\n  /**\n   * When true, the scroll view bounces horizontally when it reaches the end\n   * even if the content is smaller than the scroll view itself. The default\n   * value is true when `horizontal={true}` and false otherwise.\n   * @platform ios\n   */\n  alwaysBounceHorizontal?: ?boolean,\n  /**\n   * When true, the scroll view bounces vertically when it reaches the end\n   * even if the content is smaller than the scroll view itself. The default\n   * value is false when `horizontal={true}` and true otherwise.\n   * @platform ios\n   */\n  alwaysBounceVertical?: ?boolean,\n  /**\n   * When true, the scroll view automatically centers the content when the\n   * content is smaller than the scroll view bounds; when the content is\n   * larger than the scroll view, this property has no effect. The default\n   * value is false.\n   * @platform ios\n   */\n  centerContent?: ?boolean,\n  /**\n   * The style of the scroll indicators.\n   *\n   *   - `'default'` (the default), same as `black`.\n   *   - `'black'`, scroll indicator is black. This style is good against a light background.\n   *   - `'white'`, scroll indicator is white. This style is good against a dark background.\n   *\n   * @platform ios\n   */\n  indicatorStyle?: ?('default' | 'black' | 'white'),\n  /**\n   * When true, the ScrollView will try to lock to only vertical or horizontal\n   * scrolling while dragging.  The default value is false.\n   * @platform ios\n   */\n  directionalLockEnabled?: ?boolean,\n  /**\n   * When false, once tracking starts, won't try to drag if the touch moves.\n   * The default value is true.\n   * @platform ios\n   */\n  canCancelContentTouches?: ?boolean,\n  /**\n   * When set, the scroll view will adjust the scroll position so that the first child that is\n   * currently visible and at or beyond `minIndexForVisible` will not change position. This is\n   * useful for lists that are loading content in both directions, e.g. a chat thread, where new\n   * messages coming in might otherwise cause the scroll position to jump. A value of 0 is common,\n   * but other values such as 1 can be used to skip loading spinners or other content that should\n   * not maintain position.\n   *\n   * The optional `autoscrollToTopThreshold` can be used to make the content automatically scroll\n   * to the top after making the adjustment if the user was within the threshold of the top before\n   * the adjustment was made. This is also useful for chat-like applications where you want to see\n   * new messages scroll into place, but not if the user has scrolled up a ways and it would be\n   * disruptive to scroll a bunch.\n   *\n   * Caveat 1: Reordering elements in the scrollview with this enabled will probably cause\n   * jumpiness and jank. It can be fixed, but there are currently no plans to do so. For now,\n   * don't re-order the content of any ScrollViews or Lists that use this feature.\n   *\n   * Caveat 2: This simply uses `contentOffset` and `frame.origin` in native code to compute\n   * visibility. Occlusion, transforms, and other complexity won't be taken into account as to\n   * whether content is \"visible\" or not.\n   *\n   */\n  maintainVisibleContentPosition?: ?$ReadOnly<{|\n    minIndexForVisible: number,\n    autoscrollToTopThreshold?: ?number,\n  |}>,\n  /**\n   * The maximum allowed zoom scale. The default value is 1.0.\n   * @platform ios\n   */\n  maximumZoomScale?: ?number,\n  /**\n   * The minimum allowed zoom scale. The default value is 1.0.\n   * @platform ios\n   */\n  minimumZoomScale?: ?number,\n  /**\n   * When true, ScrollView allows use of pinch gestures to zoom in and out.\n   * The default value is true.\n   * @platform ios\n   */\n  pinchGestureEnabled?: ?boolean,\n  /**\n   * The amount by which the scroll view indicators are inset from the edges\n   * of the scroll view. This should normally be set to the same value as\n   * the `contentInset`. Defaults to `{0, 0, 0, 0}`.\n   * @platform ios\n   */\n  scrollIndicatorInsets?: ?EdgeInsetsProp,\n  /**\n   * When true, the scroll view can be programmatically scrolled beyond its\n   * content size. The default value is false.\n   * @platform ios\n   */\n  scrollToOverflowEnabled?: ?boolean,\n  /**\n   * When true, the scroll view scrolls to top when the status bar is tapped.\n   * The default value is true.\n   * @platform ios\n   */\n  scrollsToTop?: ?boolean,\n  /**\n   * Fires when the scroll view scrolls to top after the status bar has been tapped\n   * @platform ios\n   */\n  onScrollToTop?: (event: ScrollEvent) => void,\n  /**\n   * When true, shows a horizontal scroll indicator.\n   * The default value is true.\n   */\n  showsHorizontalScrollIndicator?: ?boolean,\n  /**\n   * The current scale of the scroll view content. The default value is 1.0.\n   * @platform ios\n   */\n  zoomScale?: ?number,\n  /**\n   * This property specifies how the safe area insets are used to modify the\n   * content area of the scroll view. The default value of this property is\n   * \"never\". Available on iOS 11 and later.\n   * @platform ios\n   */\n  contentInsetAdjustmentBehavior?: ?(\n    | 'automatic'\n    | 'scrollableAxes'\n    | 'never'\n    | 'always'\n  ),\n|}>;\n\ntype AndroidProps = $ReadOnly<{|\n  /**\n   * Enables nested scrolling for Android API level 21+.\n   * Nested scrolling is supported by default on iOS\n   * @platform android\n   */\n  nestedScrollEnabled?: ?boolean,\n  /**\n   * Sometimes a scrollview takes up more space than its content fills. When this is\n   * the case, this prop will fill the rest of the scrollview with a color to avoid setting\n   * a background and creating unnecessary overdraw. This is an advanced optimization\n   * that is not needed in the general case.\n   * @platform android\n   */\n  endFillColor?: ?ColorValue,\n  /**\n   * Tag used to log scroll performance on this scroll view. Will force\n   * momentum events to be turned on (see sendMomentumEvents). This doesn't do\n   * anything out of the box and you need to implement a custom native\n   * FpsListener for it to be useful.\n   * @platform android\n   */\n  scrollPerfTag?: ?string,\n  /**\n   * Used to override default value of overScroll mode.\n   *\n   * Possible values:\n   *\n   *  - `'auto'` - Default value, allow a user to over-scroll\n   *    this view only if the content is large enough to meaningfully scroll.\n   *  - `'always'` - Always allow a user to over-scroll this view.\n   *  - `'never'` - Never allow a user to over-scroll this view.\n   *\n   * @platform android\n   */\n  overScrollMode?: ?('auto' | 'always' | 'never'),\n  /**\n   * Causes the scrollbars not to turn transparent when they are not in use.\n   * The default value is false.\n   *\n   * @platform android\n   */\n  persistentScrollbar?: ?boolean,\n  /**\n   * Fades out the edges of the scroll content.\n   *\n   * If the value is greater than 0, the fading edges will be set accordingly\n   * to the current scroll direction and position,\n   * indicating if there is more content to show.\n   *\n   * The default value is 0.\n   *\n   * @platform android\n   */\n  fadingEdgeLength?: ?number,\n|}>;\n\ntype StickyHeaderComponentType = React.AbstractComponent<\n  ScrollViewStickyHeaderProps,\n  $ReadOnly<interface {setNextHeaderY: number => void}>,\n>;\n\nexport type Props = $ReadOnly<{|\n  ...ViewProps,\n  ...IOSProps,\n  ...AndroidProps,\n\n  /**\n   * These styles will be applied to the scroll view content container which\n   * wraps all of the child views. Example:\n   *\n   * ```\n   * return (\n   *   <ScrollView contentContainerStyle={styles.contentContainer}>\n   *   </ScrollView>\n   * );\n   * ...\n   * const styles = StyleSheet.create({\n   *   contentContainer: {\n   *     paddingVertical: 20\n   *   }\n   * });\n   * ```\n   */\n  contentContainerStyle?: ?ViewStyleProp,\n  /**\n   * Used to manually set the starting scroll offset.\n   * The default value is `{x: 0, y: 0}`.\n   */\n  contentOffset?: ?PointProp,\n  /**\n   * When true, the scroll view stops on the next index (in relation to scroll\n   * position at release) regardless of how fast the gesture is. This can be\n   * used for pagination when the page is less than the width of the\n   * horizontal ScrollView or the height of the vertical ScrollView. The default value is false.\n   */\n  disableIntervalMomentum?: ?boolean,\n  /**\n   * A floating-point number that determines how quickly the scroll view\n   * decelerates after the user lifts their finger. You may also use string\n   * shortcuts `\"normal\"` and `\"fast\"` which match the underlying iOS settings\n   * for `UIScrollViewDecelerationRateNormal` and\n   * `UIScrollViewDecelerationRateFast` respectively.\n   *\n   *   - `'normal'`: 0.998 on iOS, 0.985 on Android (the default)\n   *   - `'fast'`: 0.99 on iOS, 0.9 on Android\n   */\n  decelerationRate?: ?DecelerationRateType,\n  /**\n   * When true, the scroll view's children are arranged horizontally in a row\n   * instead of vertically in a column. The default value is false.\n   */\n  horizontal?: ?boolean,\n  /**\n   * If sticky headers should stick at the bottom instead of the top of the\n   * ScrollView. This is usually used with inverted ScrollViews.\n   */\n  invertStickyHeaders?: ?boolean,\n  /**\n   * Determines whether the keyboard gets dismissed in response to a drag.\n   *\n   * *Cross platform*\n   *\n   *   - `'none'` (the default), drags do not dismiss the keyboard.\n   *   - `'on-drag'`, the keyboard is dismissed when a drag begins.\n   *\n   * *iOS Only*\n   *\n   *   - `'interactive'`, the keyboard is dismissed interactively with the drag and moves in\n   *     synchrony with the touch; dragging upwards cancels the dismissal.\n   *     On android this is not supported and it will have the same behavior as 'none'.\n   */\n  keyboardDismissMode?: ?// default\n  // cross-platform\n  ('none' | 'on-drag' | 'interactive'), // ios only\n  /**\n   * Determines when the keyboard should stay visible after a tap.\n   *\n   *   - `'never'` (the default), tapping outside of the focused text input when the keyboard\n   *     is up dismisses the keyboard. When this happens, children won't receive the tap.\n   *   - `'always'`, the keyboard will not dismiss automatically, and the scroll view will not\n   *     catch taps, but children of the scroll view can catch taps.\n   *   - `'handled'`, the keyboard will not dismiss automatically when the tap was handled by\n   *     a children, (or captured by an ancestor).\n   *   - `false`, deprecated, use 'never' instead\n   *   - `true`, deprecated, use 'always' instead\n   */\n  keyboardShouldPersistTaps?: ?('always' | 'never' | 'handled' | true | false),\n  /**\n   * Called when the momentum scroll starts (scroll which occurs as the ScrollView glides to a stop).\n   */\n  onMomentumScrollBegin?: ?(event: ScrollEvent) => void,\n  /**\n   * Called when the momentum scroll ends (scroll which occurs as the ScrollView glides to a stop).\n   */\n  onMomentumScrollEnd?: ?(event: ScrollEvent) => void,\n\n  /**\n   * Fires at most once per frame during scrolling. The frequency of the\n   * events can be controlled using the `scrollEventThrottle` prop.\n   */\n  onScroll?: ?(event: ScrollEvent) => void,\n  /**\n   * Called when the user begins to drag the scroll view.\n   */\n  onScrollBeginDrag?: ?(event: ScrollEvent) => void,\n  /**\n   * Called when the user stops dragging the scroll view and it either stops\n   * or begins to glide.\n   */\n  onScrollEndDrag?: ?(event: ScrollEvent) => void,\n  /**\n   * Called when scrollable content view of the ScrollView changes.\n   *\n   * Handler function is passed the content width and content height as parameters:\n   * `(contentWidth, contentHeight)`\n   *\n   * It's implemented using onLayout handler attached to the content container\n   * which this ScrollView renders.\n   */\n  onContentSizeChange?: (contentWidth: number, contentHeight: number) => void,\n  onKeyboardDidShow?: (event: KeyboardEvent) => void,\n  onKeyboardDidHide?: (event: KeyboardEvent) => void,\n  onKeyboardWillShow?: (event: KeyboardEvent) => void,\n  onKeyboardWillHide?: (event: KeyboardEvent) => void,\n  /**\n   * When true, the scroll view stops on multiples of the scroll view's size\n   * when scrolling. This can be used for horizontal pagination. The default\n   * value is false.\n   *\n   * Note: Vertical pagination is not supported on Android.\n   */\n  pagingEnabled?: ?boolean,\n  /**\n   * When false, the view cannot be scrolled via touch interaction.\n   * The default value is true.\n   *\n   * Note that the view can always be scrolled by calling `scrollTo`.\n   */\n  scrollEnabled?: ?boolean,\n  /**\n   * This controls how often the scroll event will be fired while scrolling\n   * (as a time interval in ms). A lower number yields better accuracy for code\n   * that is tracking the scroll position, but can lead to scroll performance\n   * problems due to the volume of information being send over the bridge.\n   *\n   * Values between 0 and 17ms indicate 60fps updates are needed and throttling\n   * will be disabled.\n   *\n   * If you do not need precise scroll position tracking, set this value higher\n   * to limit the information being sent across the bridge.\n   *\n   * The default value is zero, which results in the scroll event being sent only\n   * once each time the view is scrolled.\n   */\n  scrollEventThrottle?: ?number,\n  /**\n   * When true, shows a vertical scroll indicator.\n   * The default value is true.\n   */\n  showsVerticalScrollIndicator?: ?boolean,\n  /**\n   * When true, Sticky header is hidden when scrolling down, and dock at the top\n   * when scrolling up\n   */\n  stickyHeaderHiddenOnScroll?: ?boolean,\n  /**\n   * An array of child indices determining which children get docked to the\n   * top of the screen when scrolling. For example, passing\n   * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the\n   * top of the scroll view. This property is not supported in conjunction\n   * with `horizontal={true}`.\n   */\n  stickyHeaderIndices?: ?$ReadOnlyArray<number>,\n  /**\n   * A React Component that will be used to render sticky headers.\n   * To be used together with `stickyHeaderIndices` or with `SectionList`, defaults to `ScrollViewStickyHeader`.\n   * You may need to set this if your sticky header uses custom transforms (eg. translation),\n   * for example when you want your list to have an animated hidable header.\n   */\n  StickyHeaderComponent?: StickyHeaderComponentType,\n  /**\n   * When `snapToInterval` is set, `snapToAlignment` will define the relationship\n   * of the snapping to the scroll view.\n   *\n   *   - `'start'` (the default) will align the snap at the left (horizontal) or top (vertical)\n   *   - `'center'` will align the snap in the center\n   *   - `'end'` will align the snap at the right (horizontal) or bottom (vertical)\n   */\n  snapToAlignment?: ?('start' | 'center' | 'end'),\n  /**\n   * When set, causes the scroll view to stop at multiples of the value of\n   * `snapToInterval`. This can be used for paginating through children\n   * that have lengths smaller than the scroll view. Typically used in\n   * combination with `snapToAlignment` and `decelerationRate=\"fast\"`.\n   *\n   * Overrides less configurable `pagingEnabled` prop.\n   */\n  snapToInterval?: ?number,\n  /**\n   * When set, causes the scroll view to stop at the defined offsets.\n   * This can be used for paginating through variously sized children\n   * that have lengths smaller than the scroll view. Typically used in\n   * combination with `decelerationRate=\"fast\"`.\n   *\n   * Overrides less configurable `pagingEnabled` and `snapToInterval` props.\n   */\n  snapToOffsets?: ?$ReadOnlyArray<number>,\n  /**\n   * Use in conjunction with `snapToOffsets`. By default, the beginning\n   * of the list counts as a snap offset. Set `snapToStart` to false to disable\n   * this behavior and allow the list to scroll freely between its start and\n   * the first `snapToOffsets` offset.\n   * The default value is true.\n   */\n  snapToStart?: ?boolean,\n  /**\n   * Use in conjunction with `snapToOffsets`. By default, the end\n   * of the list counts as a snap offset. Set `snapToEnd` to false to disable\n   * this behavior and allow the list to scroll freely between its end and\n   * the last `snapToOffsets` offset.\n   * The default value is true.\n   */\n  snapToEnd?: ?boolean,\n  /**\n   * Experimental: When true, offscreen child views (whose `overflow` value is\n   * `hidden`) are removed from their native backing superview when offscreen.\n   * This can improve scrolling performance on long lists. The default value is\n   * true.\n   */\n  removeClippedSubviews?: ?boolean,\n  /**\n   * A RefreshControl component, used to provide pull-to-refresh\n   * functionality for the ScrollView. Only works for vertical ScrollViews\n   * (`horizontal` prop must be `false`).\n   *\n   * See [RefreshControl](docs/refreshcontrol.html).\n   */\n  /* $FlowFixMe[unclear-type] - how to handle generic type without existential\n   * operator? */\n  refreshControl?: ?React.Element<any>,\n  children?: React.Node,\n  /**\n   * A ref to the inner View element of the ScrollView. This should be used\n   * instead of calling `getInnerViewRef`.\n   */\n  innerViewRef?: ForwardedRef<InnerViewInstance>,\n  /**\n   * A ref to the Native ScrollView component. This ref can be used to call\n   * all of ScrollView's public methods, in addition to native methods like\n   * measure, measureLayout, etc.\n   */\n  scrollViewRef?: ForwardedRef<PublicScrollViewInstance>,\n|}>;\n\ntype State = {|\n  layoutHeight: ?number,\n|};\n\nconst IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\n\nexport type ScrollViewComponentStatics = $ReadOnly<{|\n  Context: typeof ScrollViewContext,\n|}>;\n\n/**\n * Component that wraps platform ScrollView while providing\n * integration with touch locking \"responder\" system.\n *\n * Keep in mind that ScrollViews must have a bounded height in order to work,\n * since they contain unbounded-height children into a bounded container (via\n * a scroll interaction). In order to bound the height of a ScrollView, either\n * set the height of the view directly (discouraged) or make sure all parent\n * views have bounded height. Forgetting to transfer `{flex: 1}` down the\n * view stack can lead to errors here, which the element inspector makes\n * easy to debug.\n *\n * Doesn't yet support other contained responders from blocking this scroll\n * view from becoming the responder.\n *\n *\n * `<ScrollView>` vs [`<FlatList>`](https://reactnative.dev/docs/flatlist) - which one to use?\n *\n * `ScrollView` simply renders all its react child components at once. That\n * makes it very easy to understand and use.\n *\n * On the other hand, this has a performance downside. Imagine you have a very\n * long list of items you want to display, maybe several screens worth of\n * content. Creating JS components and native views for everything all at once,\n * much of which may not even be shown, will contribute to slow rendering and\n * increased memory usage.\n *\n * This is where `FlatList` comes into play. `FlatList` renders items lazily,\n * just when they are about to appear, and removes items that scroll way off\n * screen to save memory and processing time.\n *\n * `FlatList` is also handy if you want to render separators between your items,\n * multiple columns, infinite scroll loading, or any number of other features it\n * supports out of the box.\n */\nclass ScrollView extends React.Component<Props, State> {\n  static Context: typeof ScrollViewContext = ScrollViewContext;\n\n  constructor(props: Props) {\n    super(props);\n\n    this._scrollAnimatedValue = new AnimatedImplementation.Value(\n      this.props.contentOffset?.y ?? 0,\n    );\n    this._scrollAnimatedValue.setOffset(this.props.contentInset?.top ?? 0);\n  }\n\n  _scrollAnimatedValue: AnimatedImplementation.Value;\n  _scrollAnimatedValueAttachment: ?{detach: () => void, ...} = null;\n  _stickyHeaderRefs: Map<string, React.ElementRef<StickyHeaderComponentType>> =\n    new Map();\n  _headerLayoutYs: Map<string, number> = new Map();\n\n  _keyboardMetrics: ?KeyboardMetrics = null;\n  _additionalScrollOffset: number = 0;\n  _isTouching: boolean = false;\n  _lastMomentumScrollBeginTime: number = 0;\n  _lastMomentumScrollEndTime: number = 0;\n\n  // Reset to false every time becomes responder. This is used to:\n  // - Determine if the scroll view has been scrolled and therefore should\n  // refuse to give up its responder lock.\n  // - Determine if releasing should dismiss the keyboard when we are in\n  // tap-to-dismiss mode (this.props.keyboardShouldPersistTaps !== 'always').\n  _observedScrollSinceBecomingResponder: boolean = false;\n  _becameResponderWhileAnimating: boolean = false;\n  _preventNegativeScrollOffset: ?boolean = null;\n\n  _animated: ?boolean = null;\n\n  _subscriptionKeyboardWillShow: ?EventSubscription = null;\n  _subscriptionKeyboardWillHide: ?EventSubscription = null;\n  _subscriptionKeyboardDidShow: ?EventSubscription = null;\n  _subscriptionKeyboardDidHide: ?EventSubscription = null;\n\n  state: State = {\n    layoutHeight: null,\n  };\n\n  componentDidMount() {\n    if (typeof this.props.keyboardShouldPersistTaps === 'boolean') {\n      console.warn(\n        `'keyboardShouldPersistTaps={${\n          this.props.keyboardShouldPersistTaps === true ? 'true' : 'false'\n        }}' is deprecated. ` +\n          `Use 'keyboardShouldPersistTaps=\"${\n            this.props.keyboardShouldPersistTaps ? 'always' : 'never'\n          }\"' instead`,\n      );\n    }\n\n    this._keyboardMetrics = Keyboard.metrics();\n    this._additionalScrollOffset = 0;\n\n    this._subscriptionKeyboardWillShow = Keyboard.addListener(\n      'keyboardWillShow',\n      this.scrollResponderKeyboardWillShow,\n    );\n    this._subscriptionKeyboardWillHide = Keyboard.addListener(\n      'keyboardWillHide',\n      this.scrollResponderKeyboardWillHide,\n    );\n    this._subscriptionKeyboardDidShow = Keyboard.addListener(\n      'keyboardDidShow',\n      this.scrollResponderKeyboardDidShow,\n    );\n    this._subscriptionKeyboardDidHide = Keyboard.addListener(\n      'keyboardDidHide',\n      this.scrollResponderKeyboardDidHide,\n    );\n\n    this._updateAnimatedNodeAttachment();\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const prevContentInsetTop = prevProps.contentInset\n      ? prevProps.contentInset.top\n      : 0;\n    const newContentInsetTop = this.props.contentInset\n      ? this.props.contentInset.top\n      : 0;\n    if (prevContentInsetTop !== newContentInsetTop) {\n      this._scrollAnimatedValue.setOffset(newContentInsetTop || 0);\n    }\n\n    this._updateAnimatedNodeAttachment();\n  }\n\n  componentWillUnmount() {\n    if (this._subscriptionKeyboardWillShow != null) {\n      this._subscriptionKeyboardWillShow.remove();\n    }\n    if (this._subscriptionKeyboardWillHide != null) {\n      this._subscriptionKeyboardWillHide.remove();\n    }\n    if (this._subscriptionKeyboardDidShow != null) {\n      this._subscriptionKeyboardDidShow.remove();\n    }\n    if (this._subscriptionKeyboardDidHide != null) {\n      this._subscriptionKeyboardDidHide.remove();\n    }\n\n    if (this._scrollAnimatedValueAttachment) {\n      this._scrollAnimatedValueAttachment.detach();\n    }\n  }\n\n  /**\n   * Returns a reference to the underlying scroll responder, which supports\n   * operations like `scrollTo`. All ScrollView-like components should\n   * implement this method so that they can be composed while providing access\n   * to the underlying scroll responder's methods.\n   */\n  getScrollResponder: () => ScrollResponderType = () => {\n    // $FlowFixMe[unclear-type]\n    return ((this: any): ScrollResponderType);\n  };\n\n  getScrollableNode: () => ?number = () => {\n    return findNodeHandle(this._scrollView.nativeInstance);\n  };\n\n  getInnerViewNode: () => ?number = () => {\n    return findNodeHandle(this._innerView.nativeInstance);\n  };\n\n  getInnerViewRef: () => InnerViewInstance | null = () => {\n    return this._innerView.nativeInstance;\n  };\n\n  getNativeScrollRef: () => NativeScrollViewInstance | null = () => {\n    return this._scrollView.nativeInstance;\n  };\n\n  /**\n   * Scrolls to a given x, y offset, either immediately or with a smooth animation.\n   *\n   * Example:\n   *\n   * `scrollTo({x: 0, y: 0, animated: true})`\n   *\n   * Note: The weird function signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as an alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollTo: (\n    options?:\n      | {\n          x?: number,\n          y?: number,\n          animated?: boolean,\n          ...\n        }\n      | number,\n    deprecatedX?: number,\n    deprecatedAnimated?: boolean,\n  ) => void = (\n    options?:\n      | {\n          x?: number,\n          y?: number,\n          animated?: boolean,\n          ...\n        }\n      | number,\n    deprecatedX?: number,\n    deprecatedAnimated?: boolean,\n  ) => {\n    let x, y, animated;\n    if (typeof options === 'number') {\n      console.warn(\n        '`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' +\n          'animated: true})` instead.',\n      );\n      y = options;\n      x = deprecatedX;\n      animated = deprecatedAnimated;\n    } else if (options) {\n      y = options.y;\n      x = options.x;\n      animated = options.animated;\n    }\n    if (this._scrollView.nativeInstance == null) {\n      return;\n    }\n    Commands.scrollTo(\n      this._scrollView.nativeInstance,\n      x || 0,\n      y || 0,\n      animated !== false,\n    );\n  };\n\n  /**\n   * If this is a vertical ScrollView scrolls to the bottom.\n   * If this is a horizontal ScrollView scrolls to the right.\n   *\n   * Use `scrollToEnd({animated: true})` for smooth animated scrolling,\n   * `scrollToEnd({animated: false})` for immediate scrolling.\n   * If no options are passed, `animated` defaults to true.\n   */\n  scrollToEnd: (options?: ?{animated?: boolean, ...}) => void = (\n    options?: ?{animated?: boolean, ...},\n  ) => {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n    if (this._scrollView.nativeInstance == null) {\n      return;\n    }\n    Commands.scrollToEnd(this._scrollView.nativeInstance, animated);\n  };\n\n  /**\n   * Displays the scroll indicators momentarily.\n   *\n   * @platform ios\n   */\n  flashScrollIndicators: () => void = () => {\n    if (this._scrollView.nativeInstance == null) {\n      return;\n    }\n    Commands.flashScrollIndicators(this._scrollView.nativeInstance);\n  };\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {number} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's bottom \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: <T>(\n    nodeHandle: number | React.ElementRef<HostComponent<T>>,\n    additionalOffset?: number,\n    preventNegativeScrollOffset?: boolean,\n  ) => void = <T>(\n    nodeHandle: number | React.ElementRef<HostComponent<T>>,\n    additionalOffset?: number,\n    preventNegativeScrollOffset?: boolean,\n  ) => {\n    this._additionalScrollOffset = additionalOffset || 0;\n    this._preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n\n    if (this._innerView.nativeInstance == null) {\n      return;\n    }\n\n    if (typeof nodeHandle === 'number') {\n      UIManager.measureLayout(\n        nodeHandle,\n        nullthrows(findNodeHandle(this)),\n        // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n        this._textInputFocusError,\n        this._inputMeasureAndScrollToKeyboard,\n      );\n    } else {\n      nodeHandle.measureLayout(\n        this._innerView.nativeInstance,\n        this._inputMeasureAndScrollToKeyboard,\n        // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n        this._textInputFocusError,\n      );\n    }\n  };\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: (\n    rect: {|\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      animated?: boolean,\n    |},\n    animated?: boolean, // deprecated, put this inside the rect argument instead\n  ) => void = (\n    rect: {|\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      animated?: boolean,\n    |},\n    animated?: boolean, // deprecated, put this inside the rect argument instead\n  ) => {\n    invariant(Platform.OS === 'ios', 'zoomToRect is not implemented');\n    if ('animated' in rect) {\n      this._animated = rect.animated;\n      delete rect.animated;\n    } else if (typeof animated !== 'undefined') {\n      console.warn(\n        '`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead',\n      );\n    }\n\n    if (this._scrollView.nativeInstance == null) {\n      return;\n    }\n    Commands.zoomToRect(\n      this._scrollView.nativeInstance,\n      rect,\n      animated !== false,\n    );\n  };\n\n  _textInputFocusError() {\n    console.warn('Error measuring text field.');\n  }\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  _inputMeasureAndScrollToKeyboard: (\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n  ) => void = (left: number, top: number, width: number, height: number) => {\n    let keyboardScreenY = Dimensions.get('window').height;\n\n    const scrollTextInputIntoVisibleRect = () => {\n      if (this._keyboardMetrics != null) {\n        keyboardScreenY = this._keyboardMetrics.screenY;\n      }\n      let scrollOffsetY =\n        top - keyboardScreenY + height + this._additionalScrollOffset;\n\n      // By default, this can scroll with negative offset, pulling the content\n      // down so that the target component's bottom meets the keyboard's top.\n      // If requested otherwise, cap the offset at 0 minimum to avoid content\n      // shifting down.\n      if (this._preventNegativeScrollOffset === true) {\n        scrollOffsetY = Math.max(0, scrollOffsetY);\n      }\n      this.scrollTo({x: 0, y: scrollOffsetY, animated: true});\n\n      this._additionalScrollOffset = 0;\n      this._preventNegativeScrollOffset = false;\n    };\n\n    if (this._keyboardMetrics == null) {\n      // `_keyboardMetrics` is set inside `scrollResponderKeyboardWillShow` which\n      // is not guaranteed to be called before `_inputMeasureAndScrollToKeyboard` but native has already scheduled it.\n      // In case it was not called before `_inputMeasureAndScrollToKeyboard`, we postpone scrolling to\n      // text input.\n      setTimeout(() => {\n        scrollTextInputIntoVisibleRect();\n      }, 0);\n    } else {\n      scrollTextInputIntoVisibleRect();\n    }\n  };\n\n  _getKeyForIndex(index: $FlowFixMe, childArray: $FlowFixMe): $FlowFixMe {\n    const child = childArray[index];\n    return child && child.key;\n  }\n\n  _updateAnimatedNodeAttachment() {\n    if (this._scrollAnimatedValueAttachment) {\n      this._scrollAnimatedValueAttachment.detach();\n    }\n    if (\n      this.props.stickyHeaderIndices &&\n      this.props.stickyHeaderIndices.length > 0\n    ) {\n      this._scrollAnimatedValueAttachment =\n        AnimatedImplementation.attachNativeEvent(\n          this._scrollView.nativeInstance,\n          'onScroll',\n          [{nativeEvent: {contentOffset: {y: this._scrollAnimatedValue}}}],\n        );\n    }\n  }\n\n  _setStickyHeaderRef(\n    key: string,\n    ref: ?React.ElementRef<StickyHeaderComponentType>,\n  ) {\n    if (ref) {\n      this._stickyHeaderRefs.set(key, ref);\n    } else {\n      this._stickyHeaderRefs.delete(key);\n    }\n  }\n\n  _onStickyHeaderLayout(index: $FlowFixMe, event: $FlowFixMe, key: $FlowFixMe) {\n    const {stickyHeaderIndices} = this.props;\n    if (!stickyHeaderIndices) {\n      return;\n    }\n    const childArray = React.Children.toArray<$FlowFixMe>(this.props.children);\n    if (key !== this._getKeyForIndex(index, childArray)) {\n      // ignore stale layout update\n      return;\n    }\n\n    const layoutY = event.nativeEvent.layout.y;\n    this._headerLayoutYs.set(key, layoutY);\n\n    const indexOfIndex = stickyHeaderIndices.indexOf(index);\n    const previousHeaderIndex = stickyHeaderIndices[indexOfIndex - 1];\n    if (previousHeaderIndex != null) {\n      const previousHeader = this._stickyHeaderRefs.get(\n        this._getKeyForIndex(previousHeaderIndex, childArray),\n      );\n      previousHeader &&\n        previousHeader.setNextHeaderY &&\n        previousHeader.setNextHeaderY(layoutY);\n    }\n  }\n\n  _handleScroll = (e: ScrollEvent) => {\n    if (__DEV__) {\n      if (\n        this.props.onScroll &&\n        this.props.scrollEventThrottle == null &&\n        Platform.OS === 'ios'\n      ) {\n        console.log(\n          'You specified `onScroll` on a <ScrollView> but not ' +\n            '`scrollEventThrottle`. You will only receive one event. ' +\n            'Using `16` you get all the events but be aware that it may ' +\n            \"cause frame drops, use a bigger number if you don't need as \" +\n            'much precision.',\n        );\n      }\n    }\n    this._observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  };\n\n  _handleLayout = (e: LayoutEvent) => {\n    if (this.props.invertStickyHeaders === true) {\n      this.setState({layoutHeight: e.nativeEvent.layout.height});\n    }\n    if (this.props.onLayout) {\n      this.props.onLayout(e);\n    }\n  };\n\n  _handleContentOnLayout = (e: LayoutEvent) => {\n    const {width, height} = e.nativeEvent.layout;\n    this.props.onContentSizeChange &&\n      this.props.onContentSizeChange(width, height);\n  };\n\n  _innerView: RefForwarder<InnerViewInstance, InnerViewInstance> =\n    createRefForwarder(\n      (instance: InnerViewInstance): InnerViewInstance => instance,\n    );\n\n  _scrollView: RefForwarder<\n    NativeScrollViewInstance,\n    PublicScrollViewInstance,\n  > = createRefForwarder(\n    (nativeInstance: NativeScrollViewInstance): PublicScrollViewInstance => {\n      // This is a hack. Ideally we would forwardRef  to the underlying\n      // host component. However, since ScrollView has it's own methods that can be\n      // called as well, if we used the standard forwardRef then these\n      // methods wouldn't be accessible and thus be a breaking change.\n      //\n      // Therefore we edit ref to include ScrollView's public methods so that\n      // they are callable from the ref.\n\n      // $FlowFixMe[prop-missing] - Known issue with appending custom methods.\n      const publicInstance: PublicScrollViewInstance = Object.assign(\n        nativeInstance,\n        {\n          getScrollResponder: this.getScrollResponder,\n          getScrollableNode: this.getScrollableNode,\n          getInnerViewNode: this.getInnerViewNode,\n          getInnerViewRef: this.getInnerViewRef,\n          getNativeScrollRef: this.getNativeScrollRef,\n          scrollTo: this.scrollTo,\n          scrollToEnd: this.scrollToEnd,\n          flashScrollIndicators: this.flashScrollIndicators,\n          scrollResponderZoomTo: this.scrollResponderZoomTo,\n          scrollResponderScrollNativeHandleToKeyboard:\n            this.scrollResponderScrollNativeHandleToKeyboard,\n        },\n      );\n\n      return publicInstance;\n    },\n  );\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` module callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n\n  scrollResponderKeyboardWillShow: (e: KeyboardEvent) => void = (\n    e: KeyboardEvent,\n  ) => {\n    this._keyboardMetrics = e.endCoordinates;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  };\n\n  scrollResponderKeyboardWillHide: (e: KeyboardEvent) => void = (\n    e: KeyboardEvent,\n  ) => {\n    this._keyboardMetrics = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  };\n\n  scrollResponderKeyboardDidShow: (e: KeyboardEvent) => void = (\n    e: KeyboardEvent,\n  ) => {\n    this._keyboardMetrics = e.endCoordinates;\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  };\n\n  scrollResponderKeyboardDidHide: (e: KeyboardEvent) => void = (\n    e: KeyboardEvent,\n  ) => {\n    this._keyboardMetrics = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  };\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  _handleMomentumScrollBegin: (e: ScrollEvent) => void = (e: ScrollEvent) => {\n    this._lastMomentumScrollBeginTime = global.performance.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  _handleMomentumScrollEnd: (e: ScrollEvent) => void = (e: ScrollEvent) => {\n    FrameRateLogger.endScroll();\n    this._lastMomentumScrollEndTime = global.performance.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  _handleScrollBeginDrag: (e: ScrollEvent) => void = (e: ScrollEvent) => {\n    FrameRateLogger.beginScroll(); // TODO: track all scrolls after implementing onScrollEndAnimation\n\n    if (\n      Platform.OS === 'android' &&\n      this.props.keyboardDismissMode === 'on-drag'\n    ) {\n      dismissKeyboard();\n    }\n\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  _handleScrollEndDrag: (e: ScrollEvent) => void = (e: ScrollEvent) => {\n    const {velocity} = e.nativeEvent;\n    // - If we are animating, then this is a \"drag\" that is stopping the scrollview and momentum end\n    //   will fire.\n    // - If velocity is non-zero, then the interaction will stop when momentum scroll ends or\n    //   another drag starts and ends.\n    // - If we don't get velocity, better to stop the interaction twice than not stop it.\n    if (\n      !this._isAnimating() &&\n      (!velocity || (velocity.x === 0 && velocity.y === 0))\n    ) {\n      FrameRateLogger.endScroll();\n    }\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  _isAnimating: () => boolean = () => {\n    const now = global.performance.now();\n    const timeSinceLastMomentumScrollEnd =\n      now - this._lastMomentumScrollEndTime;\n    const isAnimating =\n      timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS ||\n      this._lastMomentumScrollEndTime < this._lastMomentumScrollBeginTime;\n    return isAnimating;\n  };\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  _handleResponderGrant: (e: PressEvent) => void = (e: PressEvent) => {\n    this._observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this._becameResponderWhileAnimating = this._isAnimating();\n  };\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  _handleResponderReject: () => void = () => {};\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  _handleResponderRelease: (e: PressEvent) => void = (e: PressEvent) => {\n    this._isTouching = e.nativeEvent.touches.length !== 0;\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n    if (typeof e.target === 'number') {\n      if (__DEV__) {\n        console.error(\n          'Did not expect event target to be a number. Should have been a native component',\n        );\n      }\n\n      return;\n    }\n\n    // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedInput();\n    if (\n      currentlyFocusedTextInput != null &&\n      this.props.keyboardShouldPersistTaps !== true &&\n      this.props.keyboardShouldPersistTaps !== 'always' &&\n      this._keyboardIsDismissible() &&\n      e.target !== currentlyFocusedTextInput &&\n      !this._observedScrollSinceBecomingResponder &&\n      !this._becameResponderWhileAnimating\n    ) {\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  };\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  _handleResponderTerminationRequest: () => boolean = () => {\n    return !this._observedScrollSinceBecomingResponder;\n  };\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  _handleScrollShouldSetResponder: () => boolean = () => {\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n    return this._isTouching;\n  };\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  _handleStartShouldSetResponder: (e: PressEvent) => boolean = (\n    e: PressEvent,\n  ) => {\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    const currentlyFocusedInput = TextInputState.currentlyFocusedInput();\n    if (\n      this.props.keyboardShouldPersistTaps === 'handled' &&\n      this._keyboardIsDismissible() &&\n      e.target !== currentlyFocusedInput\n    ) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not a text input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  _handleStartShouldSetResponderCapture: (e: PressEvent) => boolean = (\n    e: PressEvent,\n  ) => {\n    // The scroll view should receive taps instead of its descendants if:\n    // * it is already animating/decelerating\n    if (this._isAnimating()) {\n      return true;\n    }\n\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    // * the keyboard is up, keyboardShouldPersistTaps is 'never' (the default),\n    // and a new touch starts with a non-textinput target (in which case the\n    // first tap should be sent to the scroll view and dismiss the keyboard,\n    // then the second tap goes to the actual interior view)\n    const {keyboardShouldPersistTaps} = this.props;\n    const keyboardNeverPersistTaps =\n      !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n\n    if (typeof e.target === 'number') {\n      if (__DEV__) {\n        console.error(\n          'Did not expect event target to be a number. Should have been a native component',\n        );\n      }\n\n      return false;\n    }\n\n    // Let presses through if the soft keyboard is detached from the viewport\n    if (this._softKeyboardIsDetached()) {\n      return false;\n    }\n\n    if (\n      keyboardNeverPersistTaps &&\n      this._keyboardIsDismissible() &&\n      e.target != null &&\n      // $FlowFixMe[incompatible-call]\n      !TextInputState.isTextInput(e.target)\n    ) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Do we consider there to be a dismissible soft-keyboard open?\n   */\n  _keyboardIsDismissible: () => boolean = () => {\n    const currentlyFocusedInput = TextInputState.currentlyFocusedInput();\n\n    // We cannot dismiss the keyboard without an input to blur, even if a soft\n    // keyboard is open (e.g. when keyboard is open due to a native component\n    // not participating in TextInputState). It's also possible that the\n    // currently focused input isn't a TextInput (such as by calling ref.focus\n    // on a non-TextInput).\n    const hasFocusedTextInput =\n      currentlyFocusedInput != null &&\n      TextInputState.isTextInput(currentlyFocusedInput);\n\n    // Even if an input is focused, we may not have a keyboard to dismiss. E.g\n    // when using a physical keyboard. Ensure we have an event for an opened\n    // keyboard.\n    const softKeyboardMayBeOpen =\n      this._keyboardMetrics != null || this._keyboardEventsAreUnreliable();\n\n    return hasFocusedTextInput && softKeyboardMayBeOpen;\n  };\n\n  /**\n   * Whether an open soft keyboard is present which does not overlap the\n   * viewport. E.g. for a VR soft-keyboard which is detached from the app\n   * viewport.\n   */\n  _softKeyboardIsDetached: () => boolean = () => {\n    return this._keyboardMetrics != null && this._keyboardMetrics.height === 0;\n  };\n\n  _keyboardEventsAreUnreliable: () => boolean = () => {\n    // Android versions prior to API 30 rely on observing layout changes when\n    // `android:windowSoftInputMode` is set to `adjustResize` or `adjustPan`.\n    return Platform.OS === 'android' && Platform.Version < 30;\n  };\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {PressEvent} e Event.\n   */\n  _handleTouchEnd: (e: PressEvent) => void = (e: PressEvent) => {\n    const nativeEvent = e.nativeEvent;\n    this._isTouching = nativeEvent.touches.length !== 0;\n\n    const {keyboardShouldPersistTaps} = this.props;\n    const keyboardNeverPersistsTaps =\n      !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n\n    // Dismiss the keyboard now if we didn't become responder in capture phase\n    // to eat presses, but still want to dismiss on interaction.\n    // Don't do anything if the target of the touch event is the current input.\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedInput();\n    if (\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput &&\n      this._softKeyboardIsDetached() &&\n      this._keyboardIsDismissible() &&\n      keyboardNeverPersistsTaps\n    ) {\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  };\n\n  /**\n   * Invoke this from an `onTouchCancel` event.\n   *\n   * @param {PressEvent} e Event.\n   */\n  _handleTouchCancel: (e: PressEvent) => void = (e: PressEvent) => {\n    this._isTouching = false;\n    this.props.onTouchCancel && this.props.onTouchCancel(e);\n  };\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {PressEvent} e Touch Start event.\n   */\n  _handleTouchStart: (e: PressEvent) => void = (e: PressEvent) => {\n    this._isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  };\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {PressEvent} e Touch Start event.\n   */\n  _handleTouchMove: (e: PressEvent) => void = (e: PressEvent) => {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  };\n\n  render(): React.Node | React.Element<string> {\n    const [NativeDirectionalScrollView, NativeDirectionalScrollContentView] =\n      this.props.horizontal === true\n        ? NativeHorizontalScrollViewTuple\n        : NativeVerticalScrollViewTuple;\n\n    const contentContainerStyle = [\n      this.props.horizontal === true && styles.contentContainerHorizontal,\n      this.props.contentContainerStyle,\n    ];\n    if (__DEV__ && this.props.style !== undefined) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const style = flattenStyle(this.props.style);\n      const childLayoutProps = ['alignItems', 'justifyContent'].filter(\n        prop => style && style[prop] !== undefined,\n      );\n      invariant(\n        childLayoutProps.length === 0,\n        'ScrollView child layout (' +\n          JSON.stringify(childLayoutProps) +\n          ') must be applied through the contentContainerStyle prop.',\n      );\n    }\n\n    const contentSizeChangeProps =\n      this.props.onContentSizeChange == null\n        ? null\n        : {\n            onLayout: this._handleContentOnLayout,\n          };\n\n    const {stickyHeaderIndices} = this.props;\n    let children = this.props.children;\n\n    if (stickyHeaderIndices != null && stickyHeaderIndices.length > 0) {\n      const childArray = React.Children.toArray<$FlowFixMe>(\n        this.props.children,\n      );\n\n      children = childArray.map((child, index) => {\n        const indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;\n        if (indexOfIndex > -1) {\n          const key = child.key;\n          const nextIndex = stickyHeaderIndices[indexOfIndex + 1];\n          const StickyHeaderComponent =\n            this.props.StickyHeaderComponent || ScrollViewStickyHeader;\n          return (\n            <StickyHeaderComponent\n              key={key}\n              nativeID={'StickyHeader-' + key} /* TODO: T68258846. */\n              ref={ref => this._setStickyHeaderRef(key, ref)}\n              nextHeaderLayoutY={this._headerLayoutYs.get(\n                this._getKeyForIndex(nextIndex, childArray),\n              )}\n              onLayout={event => this._onStickyHeaderLayout(index, event, key)}\n              scrollAnimatedValue={this._scrollAnimatedValue}\n              inverted={this.props.invertStickyHeaders}\n              hiddenOnScroll={this.props.stickyHeaderHiddenOnScroll}\n              scrollViewHeight={this.state.layoutHeight}>\n              {child}\n            </StickyHeaderComponent>\n          );\n        } else {\n          return child;\n        }\n      });\n    }\n    children = (\n      <ScrollViewContext.Provider\n        value={this.props.horizontal === true ? HORIZONTAL : VERTICAL}>\n        {children}\n      </ScrollViewContext.Provider>\n    );\n\n    const hasStickyHeaders =\n      Array.isArray(stickyHeaderIndices) && stickyHeaderIndices.length > 0;\n\n    const contentContainer = (\n      <NativeDirectionalScrollContentView\n        {...contentSizeChangeProps}\n        ref={this._innerView.getForwardingRef(this.props.innerViewRef)}\n        style={contentContainerStyle}\n        removeClippedSubviews={\n          // Subview clipping causes issues with sticky headers on Android and\n          // would be hard to fix properly in a performant way.\n          Platform.OS === 'android' && hasStickyHeaders\n            ? false\n            : this.props.removeClippedSubviews\n        }\n        collapsable={false}>\n        {children}\n      </NativeDirectionalScrollContentView>\n    );\n\n    const alwaysBounceHorizontal =\n      this.props.alwaysBounceHorizontal !== undefined\n        ? this.props.alwaysBounceHorizontal\n        : this.props.horizontal;\n\n    const alwaysBounceVertical =\n      this.props.alwaysBounceVertical !== undefined\n        ? this.props.alwaysBounceVertical\n        : !this.props.horizontal;\n\n    const baseStyle =\n      this.props.horizontal === true\n        ? styles.baseHorizontal\n        : styles.baseVertical;\n    const props = {\n      ...this.props,\n      alwaysBounceHorizontal,\n      alwaysBounceVertical,\n      style: StyleSheet.compose(baseStyle, this.props.style),\n      // Override the onContentSizeChange from props, since this event can\n      // bubble up from TextInputs\n      onContentSizeChange: null,\n      onLayout: this._handleLayout,\n      onMomentumScrollBegin: this._handleMomentumScrollBegin,\n      onMomentumScrollEnd: this._handleMomentumScrollEnd,\n      onResponderGrant: this._handleResponderGrant,\n      onResponderReject: this._handleResponderReject,\n      onResponderRelease: this._handleResponderRelease,\n      onResponderTerminationRequest: this._handleResponderTerminationRequest,\n      onScrollBeginDrag: this._handleScrollBeginDrag,\n      onScrollEndDrag: this._handleScrollEndDrag,\n      onScrollShouldSetResponder: this._handleScrollShouldSetResponder,\n      onStartShouldSetResponder: this._handleStartShouldSetResponder,\n      onStartShouldSetResponderCapture:\n        this._handleStartShouldSetResponderCapture,\n      onTouchEnd: this._handleTouchEnd,\n      onTouchMove: this._handleTouchMove,\n      onTouchStart: this._handleTouchStart,\n      onTouchCancel: this._handleTouchCancel,\n      onScroll: this._handleScroll,\n      scrollEventThrottle: hasStickyHeaders\n        ? 1\n        : this.props.scrollEventThrottle,\n      sendMomentumEvents:\n        this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd\n          ? true\n          : false,\n      // default to true\n      snapToStart: this.props.snapToStart !== false,\n      // default to true\n      snapToEnd: this.props.snapToEnd !== false,\n      // pagingEnabled is overridden by snapToInterval / snapToOffsets\n      pagingEnabled: Platform.select({\n        // on iOS, pagingEnabled must be set to false to have snapToInterval / snapToOffsets work\n        ios:\n          this.props.pagingEnabled === true &&\n          this.props.snapToInterval == null &&\n          this.props.snapToOffsets == null,\n        // on Android, pagingEnabled must be set to true to have snapToInterval / snapToOffsets work\n        android:\n          this.props.pagingEnabled === true ||\n          this.props.snapToInterval != null ||\n          this.props.snapToOffsets != null,\n      }),\n    };\n\n    const {decelerationRate} = this.props;\n    if (decelerationRate != null) {\n      props.decelerationRate = processDecelerationRate(decelerationRate);\n    }\n\n    const refreshControl = this.props.refreshControl;\n    const scrollViewRef = this._scrollView.getForwardingRef(\n      this.props.scrollViewRef,\n    );\n\n    if (refreshControl) {\n      if (Platform.OS === 'ios') {\n        // On iOS the RefreshControl is a child of the ScrollView.\n        return (\n          <NativeDirectionalScrollView {...props} ref={scrollViewRef}>\n            {refreshControl}\n            {contentContainer}\n          </NativeDirectionalScrollView>\n        );\n      } else if (Platform.OS === 'android') {\n        // On Android wrap the ScrollView with a AndroidSwipeRefreshLayout.\n        // Since the ScrollView is wrapped add the style props to the\n        // AndroidSwipeRefreshLayout and use flex: 1 for the ScrollView.\n        // Note: we should split props.style on the inner and outer props\n        // however, the ScrollView still needs the baseStyle to be scrollable\n        // $FlowFixMe[underconstrained-implicit-instantiation]\n        const {outer, inner} = splitLayoutProps(flattenStyle(props.style));\n        return React.cloneElement(\n          refreshControl,\n          {style: StyleSheet.compose(baseStyle, outer)},\n          <NativeDirectionalScrollView\n            {...props}\n            style={StyleSheet.compose(baseStyle, inner)}\n            ref={scrollViewRef}>\n            {contentContainer}\n          </NativeDirectionalScrollView>,\n        );\n      }\n    }\n    return (\n      <NativeDirectionalScrollView {...props} ref={scrollViewRef}>\n        {contentContainer}\n      </NativeDirectionalScrollView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  baseVertical: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'column',\n    overflow: 'scroll',\n  },\n  baseHorizontal: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'row',\n    overflow: 'scroll',\n  },\n  contentContainerHorizontal: {\n    flexDirection: 'row',\n  },\n});\n\ntype ForwardedRef<T> = {current: null | T, ...} | ((null | T) => mixed);\n\ntype RefForwarder<TNativeInstance, TPublicInstance> = {\n  getForwardingRef: (\n    ?ForwardedRef<TPublicInstance>,\n  ) => (TNativeInstance | null) => void,\n  nativeInstance: TNativeInstance | null,\n  publicInstance: TPublicInstance | null,\n};\n\n/**\n * Helper function that should be replaced with `useCallback` and `useMergeRefs`\n * once `ScrollView` is reimplemented as a functional component.\n */\nfunction createRefForwarder<TNativeInstance, TPublicInstance>(\n  mutator: TNativeInstance => TPublicInstance,\n): RefForwarder<TNativeInstance, TPublicInstance> {\n  const state: RefForwarder<TNativeInstance, TPublicInstance> = {\n    getForwardingRef: memoize(forwardedRef => {\n      return (nativeInstance: TNativeInstance | null): void => {\n        const publicInstance =\n          nativeInstance == null ? null : mutator(nativeInstance);\n\n        state.nativeInstance = nativeInstance;\n        state.publicInstance = publicInstance;\n\n        if (forwardedRef != null) {\n          if (typeof forwardedRef === 'function') {\n            forwardedRef(publicInstance);\n          } else {\n            forwardedRef.current = publicInstance;\n          }\n        }\n      };\n    }),\n    nativeInstance: null,\n    publicInstance: null,\n  };\n\n  return state;\n}\n\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nfunction Wrapper(props, ref: (mixed => mixed) | {current: mixed, ...}) {\n  return <ScrollView {...props} scrollViewRef={ref} />;\n}\nWrapper.displayName = 'ScrollView';\nconst ForwardedScrollView = React.forwardRef(Wrapper);\n\n// $FlowFixMe[prop-missing] Add static context to ForwardedScrollView\nForwardedScrollView.Context = ScrollViewContext;\n\nForwardedScrollView.displayName = 'ScrollView';\n\nmodule.exports = ((ForwardedScrollView: $FlowFixMe): React.AbstractComponent<\n  React.ElementConfig<typeof ScrollView>,\n  PublicScrollViewInstance,\n> &\n  ScrollViewComponentStatics);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}