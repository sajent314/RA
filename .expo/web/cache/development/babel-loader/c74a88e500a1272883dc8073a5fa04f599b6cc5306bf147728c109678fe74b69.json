{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _Animated = _interopRequireDefault(require(\"../../Animated/Animated\"));\nvar _ReactFabricPublicInstanceUtils = require(\"../../Renderer/public/ReactFabricPublicInstanceUtils\");\nvar _StyleSheet = _interopRequireDefault(require(\"../../StyleSheet/StyleSheet\"));\nvar _Platform = _interopRequireDefault(require(\"../../Utilities/Platform\"));\nvar _useMergeRefs = _interopRequireDefault(require(\"../../Utilities/useMergeRefs\"));\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar React = _react;\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nvar _jsxFileName = \"C:\\\\Users\\\\stjones\\\\Desktop\\\\Ra_App\\\\node_modules\\\\react-native\\\\Libraries\\\\Components\\\\ScrollView\\\\ScrollViewStickyHeader.js\";\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nvar ScrollViewStickyHeaderWithForwardedRef = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  var inverted = props.inverted,\n    scrollViewHeight = props.scrollViewHeight,\n    hiddenOnScroll = props.hiddenOnScroll,\n    scrollAnimatedValue = props.scrollAnimatedValue,\n    _nextHeaderLayoutY = props.nextHeaderLayoutY;\n  var _useState = (0, _react.useState)(false),\n    _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n    measured = _useState2[0],\n    setMeasured = _useState2[1];\n  var _useState3 = (0, _react.useState)(0),\n    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n    layoutY = _useState4[0],\n    setLayoutY = _useState4[1];\n  var _useState5 = (0, _react.useState)(0),\n    _useState6 = (0, _slicedToArray2.default)(_useState5, 2),\n    layoutHeight = _useState6[0],\n    setLayoutHeight = _useState6[1];\n  var _useState7 = (0, _react.useState)(null),\n    _useState8 = (0, _slicedToArray2.default)(_useState7, 2),\n    translateY = _useState8[0],\n    setTranslateY = _useState8[1];\n  var _useState9 = (0, _react.useState)(_nextHeaderLayoutY),\n    _useState0 = (0, _slicedToArray2.default)(_useState9, 2),\n    nextHeaderLayoutY = _useState0[0],\n    setNextHeaderLayoutY = _useState0[1];\n  var _useState1 = (0, _react.useState)(false),\n    _useState10 = (0, _slicedToArray2.default)(_useState1, 2),\n    isFabric = _useState10[0],\n    setIsFabric = _useState10[1];\n  var callbackRef = function callbackRef(ref) {\n    if (ref == null) {\n      return;\n    }\n    ref.setNextHeaderY = function (value) {\n      setNextHeaderLayoutY(value);\n    };\n    setIsFabric((0, _ReactFabricPublicInstanceUtils.isPublicInstance)(ref));\n  };\n  var ref = (0, _useMergeRefs.default)(callbackRef, forwardedRef);\n  var offset = (0, _react.useMemo)(function () {\n    return hiddenOnScroll === true ? _Animated.default.diffClamp(scrollAnimatedValue.interpolate({\n      extrapolateLeft: 'clamp',\n      inputRange: [layoutY, layoutY + 1],\n      outputRange: [0, 1]\n    }).interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, -1]\n    }), -layoutHeight, 0) : null;\n  }, [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll]);\n  var _useState11 = (0, _react.useState)(function () {\n      var inputRange = [-1, 0];\n      var outputRange = [0, 0];\n      var initialTranslateY = scrollAnimatedValue.interpolate({\n        inputRange: inputRange,\n        outputRange: outputRange\n      });\n      if (offset != null) {\n        return _Animated.default.add(initialTranslateY, offset);\n      }\n      return initialTranslateY;\n    }),\n    _useState12 = (0, _slicedToArray2.default)(_useState11, 2),\n    animatedTranslateY = _useState12[0],\n    setAnimatedTranslateY = _useState12[1];\n  var _haveReceivedInitialZeroTranslateY = (0, _react.useRef)(true);\n  var _timer = (0, _react.useRef)(null);\n  (0, _react.useEffect)(function () {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n  var animatedValueListener = (0, _react.useCallback)(function (_ref) {\n    var value = _ref.value;\n    var _debounceTimeout = _Platform.default.OS === 'android' ? 15 : 64;\n    if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n      _haveReceivedInitialZeroTranslateY.current = true;\n      return;\n    }\n    if (_timer.current != null) {\n      clearTimeout(_timer.current);\n    }\n    _timer.current = setTimeout(function () {\n      if (value !== translateY) {\n        setTranslateY(value);\n      }\n    }, _debounceTimeout);\n  }, [translateY]);\n  (0, _react.useEffect)(function () {\n    var inputRange = [-1, 0];\n    var outputRange = [0, 0];\n    if (measured) {\n      if (inverted === true) {\n        if (scrollViewHeight != null) {\n          var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n            }\n          }\n        }\n      } else {\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (_collisionPoint >= layoutY) {\n          inputRange.push(_collisionPoint, _collisionPoint + 1);\n          outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n    var newAnimatedTranslateY = scrollAnimatedValue.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange\n    });\n    if (offset != null) {\n      newAnimatedTranslateY = _Animated.default.add(newAnimatedTranslateY, offset);\n    }\n    var animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(animatedValueListener);\n    }\n    setAnimatedTranslateY(newAnimatedTranslateY);\n    return function () {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n  var _onLayout = function _onLayout(event) {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n    props.onLayout(event);\n    var child = React.Children.only(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n  var child = React.Children.only(props.children);\n  var passthroughAnimatedPropExplicitValues = isFabric && translateY != null ? {\n    style: {\n      transform: [{\n        translateY: translateY\n      }]\n    }\n  } : null;\n  return ((0, _jsxRuntime.jsx)(_Animated.default.View, {\n      collapsable: false,\n      nativeID: props.nativeID,\n      onLayout: _onLayout,\n      ref: ref,\n      style: [child.props.style, styles.header, {\n        transform: [{\n          translateY: animatedTranslateY\n        }]\n      }],\n      passthroughAnimatedPropExplicitValues: passthroughAnimatedPropExplicitValues,\n      children: React.cloneElement(child, {\n        style: styles.fill,\n        onLayout: undefined\n      })\n    })\n  );\n});\nvar styles = _StyleSheet.default.create({\n  header: {\n    zIndex: 10,\n    position: 'relative'\n  },\n  fill: {\n    flex: 1\n  }\n});\nvar _default = exports.default = ScrollViewStickyHeaderWithForwardedRef;","map":{"version":3,"names":["_Animated","_interopRequireDefault","require","_ReactFabricPublicInstanceUtils","_StyleSheet","_Platform","_useMergeRefs","_react","_interopRequireWildcard","React","_jsxRuntime","_jsxFileName","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","ScrollViewStickyHeaderWithForwardedRef","forwardRef","ScrollViewStickyHeader","props","forwardedRef","inverted","scrollViewHeight","hiddenOnScroll","scrollAnimatedValue","_nextHeaderLayoutY","nextHeaderLayoutY","_useState","useState","_useState2","_slicedToArray2","measured","setMeasured","_useState3","_useState4","layoutY","setLayoutY","_useState5","_useState6","layoutHeight","setLayoutHeight","_useState7","_useState8","translateY","setTranslateY","_useState9","_useState0","setNextHeaderLayoutY","_useState1","_useState10","isFabric","setIsFabric","callbackRef","ref","setNextHeaderY","value","isFabricPublicInstance","useMergeRefs","offset","useMemo","Animated","diffClamp","interpolate","extrapolateLeft","inputRange","outputRange","_useState11","initialTranslateY","add","_useState12","animatedTranslateY","setAnimatedTranslateY","_haveReceivedInitialZeroTranslateY","useRef","_timer","useEffect","current","animatedValueListener","useCallback","_ref","_debounceTimeout","Platform","OS","clearTimeout","setTimeout","stickStartPoint","push","collisionPoint","newAnimatedTranslateY","animatedListenerId","addListener","removeListener","_onLayout","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","passthroughAnimatedPropExplicitValues","style","transform","jsx","View","collapsable","nativeID","styles","header","cloneElement","fill","undefined","StyleSheet","create","zIndex","position","flex","_default","exports"],"sources":["C:/Users/stjones/Desktop/Ra_App/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nimport Animated from '../../Animated/Animated';\nimport {isPublicInstance as isFabricPublicInstance} from '../../Renderer/public/ReactFabricPublicInstanceUtils';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Platform from '../../Utilities/Platform';\nimport useMergeRefs from '../../Utilities/useMergeRefs';\nimport * as React from 'react';\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react';\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<$FlowFixMe>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: Animated.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\ntype Instance = {\n  ...React.ElementRef<typeof Animated.View>,\n  setNextHeaderY: number => void,\n  ...\n};\n\nconst ScrollViewStickyHeaderWithForwardedRef: React.AbstractComponent<\n  Props,\n  Instance,\n> = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  const {\n    inverted,\n    scrollViewHeight,\n    hiddenOnScroll,\n    scrollAnimatedValue,\n    nextHeaderLayoutY: _nextHeaderLayoutY,\n  } = props;\n\n  const [measured, setMeasured] = useState<boolean>(false);\n  const [layoutY, setLayoutY] = useState<number>(0);\n  const [layoutHeight, setLayoutHeight] = useState<number>(0);\n  const [translateY, setTranslateY] = useState<?number>(null);\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] =\n    useState<?number>(_nextHeaderLayoutY);\n  const [isFabric, setIsFabric] = useState<boolean>(false);\n\n  const callbackRef = (ref: Instance | null): void => {\n    if (ref == null) {\n      return;\n    }\n    ref.setNextHeaderY = value => {\n      setNextHeaderLayoutY(value);\n    };\n    setIsFabric(isFabricPublicInstance(ref));\n  };\n  const ref: (React.ElementRef<typeof Animated.View> | null) => void =\n    // $FlowFixMe[incompatible-type] - Ref is mutated by `callbackRef`.\n    useMergeRefs<Instance | null>(callbackRef, forwardedRef);\n\n  const offset = useMemo(\n    () =>\n      hiddenOnScroll === true\n        ? Animated.diffClamp(\n            scrollAnimatedValue\n              .interpolate({\n                extrapolateLeft: 'clamp',\n                inputRange: [layoutY, layoutY + 1],\n                outputRange: ([0, 1]: Array<number>),\n              })\n              .interpolate({\n                inputRange: [0, 1],\n                outputRange: ([0, -1]: Array<number>),\n              }),\n            -layoutHeight,\n            0,\n          )\n        : null,\n    [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll],\n  );\n\n  const [animatedTranslateY, setAnimatedTranslateY] = useState<Animated.Node>(\n    () => {\n      const inputRange: Array<number> = [-1, 0];\n      const outputRange: Array<number> = [0, 0];\n      const initialTranslateY = scrollAnimatedValue.interpolate({\n        inputRange,\n        outputRange,\n      });\n\n      if (offset != null) {\n        return Animated.add(initialTranslateY, offset);\n      }\n      return initialTranslateY;\n    },\n  );\n\n  const _haveReceivedInitialZeroTranslateY = useRef<boolean>(true);\n  const _timer = useRef<?TimeoutID>(null);\n\n  useEffect(() => {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n\n  // This is called whenever the (Interpolated) Animated Value\n  // updates, which is several times per frame during scrolling.\n  // To ensure that the Fabric ShadowTree has the most recent\n  // translate style of this node, we debounce the value and then\n  // pass it through to the underlying node during render.\n  // This is:\n  // 1. Only an issue in Fabric.\n  // 2. Worse in Android than iOS. In Android, but not iOS, you\n  //    can touch and move your finger slightly and still trigger\n  //    a \"tap\" event. In iOS, moving will cancel the tap in\n  //    both Fabric and non-Fabric. On Android when you move\n  //    your finger, the hit-detection moves from the Android\n  //    platform to JS, so we need the ShadowTree to have knowledge\n  //    of the current position.\n  const animatedValueListener = useCallback(\n    ({value}: $FlowFixMe) => {\n      const _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n      // When the AnimatedInterpolation is recreated, it always initializes\n      // to a value of zero and emits a value change of 0 to its listeners.\n      if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n        _haveReceivedInitialZeroTranslateY.current = true;\n        return;\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n      _timer.current = setTimeout(() => {\n        if (value !== translateY) {\n          setTranslateY(value);\n        }\n      }, _debounceTimeout);\n    },\n    [translateY],\n  );\n\n  useEffect(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted === true) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    let newAnimatedTranslateY: Animated.Node = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n\n    // add the event listener\n    let animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(\n        animatedValueListener,\n      );\n    }\n\n    setAnimatedTranslateY(newAnimatedTranslateY);\n\n    // clean up the event listener and timer\n    return () => {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n\n  const _onLayout = (event: LayoutEvent) => {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n\n    props.onLayout(event);\n    const child = React.Children.only<$FlowFixMe>(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  const child = React.Children.only<$FlowFixMe>(props.children);\n\n  // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\n  const passthroughAnimatedPropExplicitValues =\n    isFabric && translateY != null\n      ? {\n          style: {transform: [{translateY: translateY}]},\n        }\n      : null;\n\n  return (\n    /* $FlowFixMe[prop-missing] passthroughAnimatedPropExplicitValues isn't properly\n       included in the Animated.View flow type. */\n    <Animated.View\n      collapsable={false}\n      nativeID={props.nativeID}\n      onLayout={_onLayout}\n      ref={ref}\n      style={[\n        child.props.style,\n        styles.header,\n        {transform: [{translateY: animatedTranslateY}]},\n      ]}\n      passthroughAnimatedPropExplicitValues={\n        passthroughAnimatedPropExplicitValues\n      }>\n      {React.cloneElement(child, {\n        style: styles.fill, // We transfer the child style to the wrapper.\n        onLayout: undefined, // we call this manually through our this._onLayout\n      })}\n    </Animated.View>\n  );\n});\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nexport default ScrollViewStickyHeaderWithForwardedRef;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}