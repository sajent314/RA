{"ast":null,"code":"'use client';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nvar _Dimensions = _interopRequireDefault(require(\"../Dimensions\"));\nvar _dismissKeyboard = _interopRequireDefault(require(\"../../modules/dismissKeyboard\"));\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\nvar _mergeRefs = _interopRequireDefault(require(\"../../modules/mergeRefs\"));\nvar _Platform = _interopRequireDefault(require(\"../Platform\"));\nvar _ScrollViewBase = _interopRequireDefault(require(\"./ScrollViewBase\"));\nvar _StyleSheet = _interopRequireDefault(require(\"../StyleSheet\"));\nvar _TextInputState = _interopRequireDefault(require(\"../../modules/TextInputState\"));\nvar _UIManager = _interopRequireDefault(require(\"../UIManager\"));\nvar _View = _interopRequireDefault(require(\"../View\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _warning = _interopRequireDefault(require(\"fbjs/lib/warning\"));\nfunction _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nvar _excluded = [\"contentContainerStyle\", \"horizontal\", \"onContentSizeChange\", \"refreshControl\", \"stickyHeaderIndices\", \"pagingEnabled\", \"forwardedRef\", \"keyboardDismissMode\", \"onScroll\", \"centerContent\"];\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollView = function (_React$Component) {\n  function ScrollView() {\n    var _this;\n    (0, _classCallCheck2.default)(this, ScrollView);\n    _this = _callSuper(this, ScrollView, arguments);\n    _this._scrollNodeRef = null;\n    _this._innerViewRef = null;\n    _this.isTouching = false;\n    _this.lastMomentumScrollBeginTime = 0;\n    _this.lastMomentumScrollEndTime = 0;\n    _this.observedScrollSinceBecomingResponder = false;\n    _this.becameResponderWhileAnimating = false;\n    _this.scrollResponderHandleScrollShouldSetResponder = function () {\n      return _this.isTouching;\n    };\n    _this.scrollResponderHandleStartShouldSetResponderCapture = function (e) {\n      return _this.scrollResponderIsAnimating();\n    };\n    _this.scrollResponderHandleTerminationRequest = function () {\n      return !_this.observedScrollSinceBecomingResponder;\n    };\n    _this.scrollResponderHandleTouchEnd = function (e) {\n      var nativeEvent = e.nativeEvent;\n      _this.isTouching = nativeEvent.touches.length !== 0;\n      _this.props.onTouchEnd && _this.props.onTouchEnd(e);\n    };\n    _this.scrollResponderHandleResponderRelease = function (e) {\n      _this.props.onResponderRelease && _this.props.onResponderRelease(e);\n      var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedField();\n      if (!_this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !_this.observedScrollSinceBecomingResponder && !_this.becameResponderWhileAnimating) {\n        _this.props.onScrollResponderKeyboardDismissed && _this.props.onScrollResponderKeyboardDismissed(e);\n        _TextInputState.default.blurTextInput(currentlyFocusedTextInput);\n      }\n    };\n    _this.scrollResponderHandleScroll = function (e) {\n      _this.observedScrollSinceBecomingResponder = true;\n      _this.props.onScroll && _this.props.onScroll(e);\n    };\n    _this.scrollResponderHandleResponderGrant = function (e) {\n      _this.observedScrollSinceBecomingResponder = false;\n      _this.props.onResponderGrant && _this.props.onResponderGrant(e);\n      _this.becameResponderWhileAnimating = _this.scrollResponderIsAnimating();\n    };\n    _this.scrollResponderHandleScrollBeginDrag = function (e) {\n      _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);\n    };\n    _this.scrollResponderHandleScrollEndDrag = function (e) {\n      _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);\n    };\n    _this.scrollResponderHandleMomentumScrollBegin = function (e) {\n      _this.lastMomentumScrollBeginTime = Date.now();\n      _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);\n    };\n    _this.scrollResponderHandleMomentumScrollEnd = function (e) {\n      _this.lastMomentumScrollEndTime = Date.now();\n      _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);\n    };\n    _this.scrollResponderHandleTouchStart = function (e) {\n      _this.isTouching = true;\n      _this.props.onTouchStart && _this.props.onTouchStart(e);\n    };\n    _this.scrollResponderHandleTouchMove = function (e) {\n      _this.props.onTouchMove && _this.props.onTouchMove(e);\n    };\n    _this.scrollResponderIsAnimating = function () {\n      var now = Date.now();\n      var timeSinceLastMomentumScrollEnd = now - _this.lastMomentumScrollEndTime;\n      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || _this.lastMomentumScrollEndTime < _this.lastMomentumScrollBeginTime;\n      return isAnimating;\n    };\n    _this.scrollResponderScrollTo = function (x, y, animated) {\n      if (typeof x === 'number') {\n        console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref = x || emptyObject;\n        x = _ref.x;\n        y = _ref.y;\n        animated = _ref.animated;\n      }\n      var node = _this.getScrollableNode();\n      var left = x || 0;\n      var top = y || 0;\n      if (node != null) {\n        if (typeof node.scroll === 'function') {\n          node.scroll({\n            top: top,\n            left: left,\n            behavior: !animated ? 'auto' : 'smooth'\n          });\n        } else {\n          node.scrollLeft = left;\n          node.scrollTop = top;\n        }\n      }\n    };\n    _this.scrollResponderZoomTo = function (rect, animated) {\n      if (_Platform.default.OS !== 'ios') {\n        (0, _invariant.default)('zoomToRect is not implemented');\n      }\n    };\n    _this.scrollResponderScrollNativeHandleToKeyboard = function (nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n      _this.additionalScrollOffset = additionalOffset || 0;\n      _this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n      _UIManager.default.measureLayout(nodeHandle, _this.getInnerViewNode(), _this.scrollResponderTextInputFocusError, _this.scrollResponderInputMeasureAndScrollToKeyboard);\n    };\n    _this.scrollResponderInputMeasureAndScrollToKeyboard = function (left, top, width, height) {\n      var keyboardScreenY = _Dimensions.default.get('window').height;\n      if (_this.keyboardWillOpenTo) {\n        keyboardScreenY = _this.keyboardWillOpenTo.endCoordinates.screenY;\n      }\n      var scrollOffsetY = top - keyboardScreenY + height + _this.additionalScrollOffset;\n      if (_this.preventNegativeScrollOffset) {\n        scrollOffsetY = Math.max(0, scrollOffsetY);\n      }\n      _this.scrollResponderScrollTo({\n        x: 0,\n        y: scrollOffsetY,\n        animated: true\n      });\n      _this.additionalOffset = 0;\n      _this.preventNegativeScrollOffset = false;\n    };\n    _this.scrollResponderKeyboardWillShow = function (e) {\n      _this.keyboardWillOpenTo = e;\n      _this.props.onKeyboardWillShow && _this.props.onKeyboardWillShow(e);\n    };\n    _this.scrollResponderKeyboardWillHide = function (e) {\n      _this.keyboardWillOpenTo = null;\n      _this.props.onKeyboardWillHide && _this.props.onKeyboardWillHide(e);\n    };\n    _this.scrollResponderKeyboardDidShow = function (e) {\n      if (e) {\n        _this.keyboardWillOpenTo = e;\n      }\n      _this.props.onKeyboardDidShow && _this.props.onKeyboardDidShow(e);\n    };\n    _this.scrollResponderKeyboardDidHide = function (e) {\n      _this.keyboardWillOpenTo = null;\n      _this.props.onKeyboardDidHide && _this.props.onKeyboardDidHide(e);\n    };\n    _this.flashScrollIndicators = function () {\n      _this.scrollResponderFlashScrollIndicators();\n    };\n    _this.getScrollResponder = function () {\n      return _this;\n    };\n    _this.getScrollableNode = function () {\n      return _this._scrollNodeRef;\n    };\n    _this.getInnerViewRef = function () {\n      return _this._innerViewRef;\n    };\n    _this.getInnerViewNode = function () {\n      return _this._innerViewRef;\n    };\n    _this.getNativeScrollRef = function () {\n      return _this._scrollNodeRef;\n    };\n    _this.scrollTo = function (y, x, animated) {\n      if (typeof y === 'number') {\n        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref2 = y || emptyObject;\n        x = _ref2.x;\n        y = _ref2.y;\n        animated = _ref2.animated;\n      }\n      _this.scrollResponderScrollTo({\n        x: x || 0,\n        y: y || 0,\n        animated: animated !== false\n      });\n    };\n    _this.scrollToEnd = function (options) {\n      var animated = (options && options.animated) !== false;\n      var horizontal = _this.props.horizontal;\n      var scrollResponderNode = _this.getScrollableNode();\n      var x = horizontal ? scrollResponderNode.scrollWidth : 0;\n      var y = horizontal ? 0 : scrollResponderNode.scrollHeight;\n      _this.scrollResponderScrollTo({\n        x: x,\n        y: y,\n        animated: animated\n      });\n    };\n    _this._handleContentOnLayout = function (e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        width = _e$nativeEvent$layout.width,\n        height = _e$nativeEvent$layout.height;\n      _this.props.onContentSizeChange(width, height);\n    };\n    _this._handleScroll = function (e) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (_this.props.onScroll && _this.props.scrollEventThrottle == null) {\n          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + \"cause frame drops, use a bigger number if you don't need as \" + 'much precision.');\n        }\n      }\n      if (_this.props.keyboardDismissMode === 'on-drag') {\n        (0, _dismissKeyboard.default)();\n      }\n      _this.scrollResponderHandleScroll(e);\n    };\n    _this._setInnerViewRef = function (node) {\n      _this._innerViewRef = node;\n    };\n    _this._setScrollNodeRef = function (node) {\n      _this._scrollNodeRef = node;\n      if (node != null) {\n        node.getScrollResponder = _this.getScrollResponder;\n        node.getInnerViewNode = _this.getInnerViewNode;\n        node.getInnerViewRef = _this.getInnerViewRef;\n        node.getNativeScrollRef = _this.getNativeScrollRef;\n        node.getScrollableNode = _this.getScrollableNode;\n        node.scrollTo = _this.scrollTo;\n        node.scrollToEnd = _this.scrollToEnd;\n        node.flashScrollIndicators = _this.flashScrollIndicators;\n        node.scrollResponderZoomTo = _this.scrollResponderZoomTo;\n        node.scrollResponderScrollNativeHandleToKeyboard = _this.scrollResponderScrollNativeHandleToKeyboard;\n      }\n      var ref = (0, _mergeRefs.default)(_this.props.forwardedRef);\n      ref(node);\n    };\n    return _this;\n  }\n  (0, _inherits2.default)(ScrollView, _React$Component);\n  return (0, _createClass2.default)(ScrollView, [{\n    key: \"scrollResponderHandleStartShouldSetResponder\",\n    value: function scrollResponderHandleStartShouldSetResponder() {\n      return false;\n    }\n  }, {\n    key: \"scrollResponderHandleResponderReject\",\n    value: function scrollResponderHandleResponderReject() {\n      (0, _warning.default)(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n    }\n  }, {\n    key: \"scrollResponderFlashScrollIndicators\",\n    value: function scrollResponderFlashScrollIndicators() {}\n  }, {\n    key: \"scrollResponderTextInputFocusError\",\n    value: function scrollResponderTextInputFocusError(e) {\n      console.error('Error measuring text field: ', e);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n        contentContainerStyle = _this$props.contentContainerStyle,\n        horizontal = _this$props.horizontal,\n        onContentSizeChange = _this$props.onContentSizeChange,\n        refreshControl = _this$props.refreshControl,\n        stickyHeaderIndices = _this$props.stickyHeaderIndices,\n        pagingEnabled = _this$props.pagingEnabled,\n        forwardedRef = _this$props.forwardedRef,\n        keyboardDismissMode = _this$props.keyboardDismissMode,\n        onScroll = _this$props.onScroll,\n        centerContent = _this$props.centerContent,\n        other = (0, _objectWithoutPropertiesLoose2.default)(_this$props, _excluded);\n      if (process.env.NODE_ENV !== 'production' && this.props.style) {\n        var style = _StyleSheet.default.flatten(this.props.style);\n        var childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {\n          return style && style[prop] !== undefined;\n        });\n        (0, _invariant.default)(childLayoutProps.length === 0, \"ScrollView child layout (\" + JSON.stringify(childLayoutProps) + \") \" + 'must be applied through the contentContainerStyle prop.');\n      }\n      var contentSizeChangeProps = {};\n      if (onContentSizeChange) {\n        contentSizeChangeProps = {\n          onLayout: this._handleContentOnLayout\n        };\n      }\n      var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);\n      var children = hasStickyHeaderIndices || pagingEnabled ? _react.default.Children.map(this.props.children, function (child, i) {\n        var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;\n        if (child != null && (isSticky || pagingEnabled)) {\n          return _react.default.createElement(_View.default, {\n            style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]\n          }, child);\n        } else {\n          return child;\n        }\n      }) : this.props.children;\n      var contentContainer = _react.default.createElement(_View.default, (0, _extends2.default)({}, contentSizeChangeProps, {\n        children: children,\n        collapsable: false,\n        ref: this._setInnerViewRef,\n        style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]\n      }));\n      var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;\n      var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;\n      var props = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, other), {}, {\n        style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],\n        onTouchStart: this.scrollResponderHandleTouchStart,\n        onTouchMove: this.scrollResponderHandleTouchMove,\n        onTouchEnd: this.scrollResponderHandleTouchEnd,\n        onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,\n        onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,\n        onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,\n        onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,\n        onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,\n        onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,\n        onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,\n        onScroll: this._handleScroll,\n        onResponderGrant: this.scrollResponderHandleResponderGrant,\n        onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,\n        onResponderTerminate: this.scrollResponderHandleTerminate,\n        onResponderRelease: this.scrollResponderHandleResponderRelease,\n        onResponderReject: this.scrollResponderHandleResponderReject\n      });\n      var ScrollViewClass = _ScrollViewBase.default;\n      (0, _invariant.default)(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');\n      var scrollView = _react.default.createElement(ScrollViewClass, (0, _extends2.default)({}, props, {\n        ref: this._setScrollNodeRef\n      }), contentContainer);\n      if (refreshControl) {\n        return _react.default.cloneElement(refreshControl, {\n          style: props.style\n        }, scrollView);\n      }\n      return scrollView;\n    }\n  }]);\n}(_react.default.Component);\nvar commonStyle = {\n  flexGrow: 1,\n  flexShrink: 1,\n  transform: 'translateZ(0)',\n  WebkitOverflowScrolling: 'touch'\n};\nvar styles = _StyleSheet.default.create({\n  baseVertical: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonStyle), {}, {\n    flexDirection: 'column',\n    overflowX: 'hidden',\n    overflowY: 'auto'\n  }),\n  baseHorizontal: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, commonStyle), {}, {\n    flexDirection: 'row',\n    overflowX: 'auto',\n    overflowY: 'hidden'\n  }),\n  contentContainerHorizontal: {\n    flexDirection: 'row'\n  },\n  contentContainerCenterContent: {\n    justifyContent: 'center',\n    flexGrow: 1\n  },\n  stickyHeader: {\n    position: 'sticky',\n    top: 0,\n    zIndex: 10\n  },\n  pagingEnabledHorizontal: {\n    scrollSnapType: 'x mandatory'\n  },\n  pagingEnabledVertical: {\n    scrollSnapType: 'y mandatory'\n  },\n  pagingEnabledChild: {\n    scrollSnapAlign: 'start'\n  }\n});\nvar ForwardedScrollView = _react.default.forwardRef(function (props, forwardedRef) {\n  return _react.default.createElement(ScrollView, (0, _extends2.default)({}, props, {\n    forwardedRef: forwardedRef\n  }));\n});\nForwardedScrollView.displayName = 'ScrollView';\nvar _default = exports.default = ForwardedScrollView;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_classCallCheck2","_createClass2","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","_objectSpread2","_extends2","_objectWithoutPropertiesLoose2","_Dimensions","_dismissKeyboard","_invariant","_mergeRefs","_Platform","_ScrollViewBase","_StyleSheet","_TextInputState","_UIManager","_View","_react","_warning","_callSuper","t","o","e","_isNativeReflectConstruct","Reflect","construct","constructor","apply","Boolean","prototype","valueOf","call","_excluded","emptyObject","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollView","_React$Component","_this","arguments","_scrollNodeRef","_innerViewRef","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","scrollResponderHandleStartShouldSetResponderCapture","scrollResponderIsAnimating","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","props","onTouchEnd","scrollResponderHandleResponderRelease","onResponderRelease","currentlyFocusedTextInput","TextInputState","currentlyFocusedField","keyboardShouldPersistTaps","target","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","Date","now","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderScrollTo","x","y","animated","console","warn","_ref","node","getScrollableNode","left","top","scroll","behavior","scrollLeft","scrollTop","scrollResponderZoomTo","rect","Platform","OS","invariant","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","UIManager","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","width","height","keyboardScreenY","Dimensions","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","scrollResponderKeyboardWillShow","onKeyboardWillShow","scrollResponderKeyboardWillHide","onKeyboardWillHide","scrollResponderKeyboardDidShow","onKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardDidHide","flashScrollIndicators","scrollResponderFlashScrollIndicators","getScrollResponder","getInnerViewRef","getNativeScrollRef","scrollTo","_ref2","scrollToEnd","options","horizontal","scrollResponderNode","scrollWidth","scrollHeight","_handleContentOnLayout","_e$nativeEvent$layout","layout","onContentSizeChange","_handleScroll","process","env","NODE_ENV","scrollEventThrottle","log","keyboardDismissMode","dismissKeyboard","_setInnerViewRef","_setScrollNodeRef","ref","mergeRefs","forwardedRef","key","scrollResponderHandleStartShouldSetResponder","scrollResponderHandleResponderReject","warning","error","render","_this$props","contentContainerStyle","refreshControl","stickyHeaderIndices","pagingEnabled","centerContent","other","_objectWithoutPropertiesLoose","style","StyleSheet","flatten","childLayoutProps","filter","prop","undefined","JSON","stringify","contentSizeChangeProps","onLayout","hasStickyHeaderIndices","Array","isArray","children","React","Children","map","child","i","isSticky","indexOf","createElement","View","styles","stickyHeader","pagingEnabledChild","contentContainer","_extends","collapsable","contentContainerHorizontal","contentContainerCenterContent","baseStyle","baseHorizontal","baseVertical","pagingEnabledStyle","pagingEnabledHorizontal","pagingEnabledVertical","_objectSpread","onStartShouldSetResponder","onStartShouldSetResponderCapture","onScrollShouldSetResponder","onResponderTerminationRequest","onResponderTerminate","scrollResponderHandleTerminate","onResponderReject","ScrollViewClass","ScrollViewBase","scrollView","cloneElement","Component","commonStyle","flexGrow","flexShrink","transform","WebkitOverflowScrolling","create","flexDirection","overflowX","overflowY","justifyContent","position","zIndex","scrollSnapType","scrollSnapAlign","ForwardedScrollView","forwardRef","displayName","_default"],"sources":["C:/Users/stjones/Desktop/Ra_App/node_modules/react-native-web/dist/exports/ScrollView/index.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n'use client';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nvar _excluded = [\"contentContainerStyle\", \"horizontal\", \"onContentSizeChange\", \"refreshControl\", \"stickyHeaderIndices\", \"pagingEnabled\", \"forwardedRef\", \"keyboardDismissMode\", \"onScroll\", \"centerContent\"];\nimport Dimensions from '../Dimensions';\nimport dismissKeyboard from '../../modules/dismissKeyboard';\nimport invariant from 'fbjs/lib/invariant';\nimport mergeRefs from '../../modules/mergeRefs';\nimport Platform from '../Platform';\nimport ScrollViewBase from './ScrollViewBase';\nimport StyleSheet from '../StyleSheet';\nimport TextInputState from '../../modules/TextInputState';\nimport UIManager from '../UIManager';\nimport View from '../View';\nimport React from 'react';\nimport warning from 'fbjs/lib/warning';\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nclass ScrollView extends React.Component {\n  constructor() {\n    super(...arguments);\n    this._scrollNodeRef = null;\n    this._innerViewRef = null;\n    this.isTouching = false;\n    this.lastMomentumScrollBeginTime = 0;\n    this.lastMomentumScrollEndTime = 0;\n    this.observedScrollSinceBecomingResponder = false;\n    this.becameResponderWhileAnimating = false;\n    this.scrollResponderHandleScrollShouldSetResponder = () => {\n      return this.isTouching;\n    };\n    this.scrollResponderHandleStartShouldSetResponderCapture = e => {\n      // First see if we want to eat taps while the keyboard is up\n      // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n      // if (!this.props.keyboardShouldPersistTaps &&\n      //   currentlyFocusedTextInput != null &&\n      //   e.target !== currentlyFocusedTextInput) {\n      //   return true;\n      // }\n      return this.scrollResponderIsAnimating();\n    };\n    this.scrollResponderHandleTerminationRequest = () => {\n      return !this.observedScrollSinceBecomingResponder;\n    };\n    this.scrollResponderHandleTouchEnd = e => {\n      var nativeEvent = e.nativeEvent;\n      this.isTouching = nativeEvent.touches.length !== 0;\n      this.props.onTouchEnd && this.props.onTouchEnd(e);\n    };\n    this.scrollResponderHandleResponderRelease = e => {\n      this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n      // By default scroll views will unfocus a textField\n      // if another touch occurs outside of it\n      var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n      if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating) {\n        this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n        TextInputState.blurTextInput(currentlyFocusedTextInput);\n      }\n    };\n    this.scrollResponderHandleScroll = e => {\n      this.observedScrollSinceBecomingResponder = true;\n      this.props.onScroll && this.props.onScroll(e);\n    };\n    this.scrollResponderHandleResponderGrant = e => {\n      this.observedScrollSinceBecomingResponder = false;\n      this.props.onResponderGrant && this.props.onResponderGrant(e);\n      this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n    };\n    this.scrollResponderHandleScrollBeginDrag = e => {\n      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n    };\n    this.scrollResponderHandleScrollEndDrag = e => {\n      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n    };\n    this.scrollResponderHandleMomentumScrollBegin = e => {\n      this.lastMomentumScrollBeginTime = Date.now();\n      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n    };\n    this.scrollResponderHandleMomentumScrollEnd = e => {\n      this.lastMomentumScrollEndTime = Date.now();\n      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n    };\n    this.scrollResponderHandleTouchStart = e => {\n      this.isTouching = true;\n      this.props.onTouchStart && this.props.onTouchStart(e);\n    };\n    this.scrollResponderHandleTouchMove = e => {\n      this.props.onTouchMove && this.props.onTouchMove(e);\n    };\n    this.scrollResponderIsAnimating = () => {\n      var now = Date.now();\n      var timeSinceLastMomentumScrollEnd = now - this.lastMomentumScrollEndTime;\n      var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;\n      return isAnimating;\n    };\n    this.scrollResponderScrollTo = (x, y, animated) => {\n      if (typeof x === 'number') {\n        console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref = x || emptyObject;\n        x = _ref.x;\n        y = _ref.y;\n        animated = _ref.animated;\n      }\n      var node = this.getScrollableNode();\n      var left = x || 0;\n      var top = y || 0;\n      if (node != null) {\n        if (typeof node.scroll === 'function') {\n          node.scroll({\n            top,\n            left,\n            behavior: !animated ? 'auto' : 'smooth'\n          });\n        } else {\n          node.scrollLeft = left;\n          node.scrollTop = top;\n        }\n      }\n    };\n    this.scrollResponderZoomTo = (rect, animated) => {\n      if (Platform.OS !== 'ios') {\n        invariant('zoomToRect is not implemented');\n      }\n    };\n    this.scrollResponderScrollNativeHandleToKeyboard = (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {\n      this.additionalScrollOffset = additionalOffset || 0;\n      this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n      UIManager.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n    };\n    this.scrollResponderInputMeasureAndScrollToKeyboard = (left, top, width, height) => {\n      var keyboardScreenY = Dimensions.get('window').height;\n      if (this.keyboardWillOpenTo) {\n        keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n      }\n      var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;\n\n      // By default, this can scroll with negative offset, pulling the content\n      // down so that the target component's bottom meets the keyboard's top.\n      // If requested otherwise, cap the offset at 0 minimum to avoid content\n      // shifting down.\n      if (this.preventNegativeScrollOffset) {\n        scrollOffsetY = Math.max(0, scrollOffsetY);\n      }\n      this.scrollResponderScrollTo({\n        x: 0,\n        y: scrollOffsetY,\n        animated: true\n      });\n      this.additionalOffset = 0;\n      this.preventNegativeScrollOffset = false;\n    };\n    this.scrollResponderKeyboardWillShow = e => {\n      this.keyboardWillOpenTo = e;\n      this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n    };\n    this.scrollResponderKeyboardWillHide = e => {\n      this.keyboardWillOpenTo = null;\n      this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n    };\n    this.scrollResponderKeyboardDidShow = e => {\n      // TODO(7693961): The event for DidShow is not available on iOS yet.\n      // Use the one from WillShow and do not assign.\n      if (e) {\n        this.keyboardWillOpenTo = e;\n      }\n      this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n    };\n    this.scrollResponderKeyboardDidHide = e => {\n      this.keyboardWillOpenTo = null;\n      this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n    };\n    this.flashScrollIndicators = () => {\n      this.scrollResponderFlashScrollIndicators();\n    };\n    this.getScrollResponder = () => {\n      return this;\n    };\n    this.getScrollableNode = () => {\n      return this._scrollNodeRef;\n    };\n    this.getInnerViewRef = () => {\n      return this._innerViewRef;\n    };\n    this.getInnerViewNode = () => {\n      return this._innerViewRef;\n    };\n    this.getNativeScrollRef = () => {\n      return this._scrollNodeRef;\n    };\n    this.scrollTo = (y, x, animated) => {\n      if (typeof y === 'number') {\n        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');\n      } else {\n        var _ref2 = y || emptyObject;\n        x = _ref2.x;\n        y = _ref2.y;\n        animated = _ref2.animated;\n      }\n      this.scrollResponderScrollTo({\n        x: x || 0,\n        y: y || 0,\n        animated: animated !== false\n      });\n    };\n    this.scrollToEnd = options => {\n      // Default to true\n      var animated = (options && options.animated) !== false;\n      var horizontal = this.props.horizontal;\n      var scrollResponderNode = this.getScrollableNode();\n      var x = horizontal ? scrollResponderNode.scrollWidth : 0;\n      var y = horizontal ? 0 : scrollResponderNode.scrollHeight;\n      this.scrollResponderScrollTo({\n        x,\n        y,\n        animated\n      });\n    };\n    this._handleContentOnLayout = e => {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        width = _e$nativeEvent$layout.width,\n        height = _e$nativeEvent$layout.height;\n      this.props.onContentSizeChange(width, height);\n    };\n    this._handleScroll = e => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.props.onScroll && this.props.scrollEventThrottle == null) {\n          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + \"cause frame drops, use a bigger number if you don't need as \" + 'much precision.');\n        }\n      }\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        dismissKeyboard();\n      }\n      this.scrollResponderHandleScroll(e);\n    };\n    this._setInnerViewRef = node => {\n      this._innerViewRef = node;\n    };\n    this._setScrollNodeRef = node => {\n      this._scrollNodeRef = node;\n      // ScrollView needs to add more methods to the hostNode in addition to those\n      // added by `usePlatformMethods`. This is temporarily until an API like\n      // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.\n      if (node != null) {\n        node.getScrollResponder = this.getScrollResponder;\n        node.getInnerViewNode = this.getInnerViewNode;\n        node.getInnerViewRef = this.getInnerViewRef;\n        node.getNativeScrollRef = this.getNativeScrollRef;\n        node.getScrollableNode = this.getScrollableNode;\n        node.scrollTo = this.scrollTo;\n        node.scrollToEnd = this.scrollToEnd;\n        node.flashScrollIndicators = this.flashScrollIndicators;\n        node.scrollResponderZoomTo = this.scrollResponderZoomTo;\n        node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;\n      }\n      var ref = mergeRefs(this.props.forwardedRef);\n      ref(node);\n    };\n  }\n  /**\n   * ------------------------------------------------------\n   * START SCROLLRESPONDER\n   * ------------------------------------------------------\n   */\n  // Reset to false every time becomes responder. This is used to:\n  // - Determine if the scroll view has been scrolled and therefore should\n  // refuse to give up its responder lock.\n  // - Determine if releasing should dismiss the keyboard when we are in\n  // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  }\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject() {\n    warning(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  }\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n\n  /**\n   * A helper function to scroll to a specific point in the scrollview.\n   * This is currently used to help focus on child textviews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators() {}\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n\n  scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  }\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n\n  /**\n   * ------------------------------------------------------\n   * END SCROLLRESPONDER\n   * ------------------------------------------------------\n   */\n\n  /**\n   * Returns a reference to the underlying scroll responder, which supports\n   * operations like `scrollTo`. All ScrollView-like components should\n   * implement this method so that they can be composed while providing access\n   * to the underlying scroll responder's methods.\n   */\n\n  /**\n   * Scrolls to a given x, y offset, either immediately or with a smooth animation.\n   * Syntax:\n   *\n   * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n\n  /**\n   * If this is a vertical ScrollView scrolls to the bottom.\n   * If this is a horizontal ScrollView scrolls to the right.\n   *\n   * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,\n   * `scrollToEnd({ animated: false })` for immediate scrolling.\n   * If no options are passed, `animated` defaults to true.\n   */\n\n  render() {\n    var _this$props = this.props,\n      contentContainerStyle = _this$props.contentContainerStyle,\n      horizontal = _this$props.horizontal,\n      onContentSizeChange = _this$props.onContentSizeChange,\n      refreshControl = _this$props.refreshControl,\n      stickyHeaderIndices = _this$props.stickyHeaderIndices,\n      pagingEnabled = _this$props.pagingEnabled,\n      forwardedRef = _this$props.forwardedRef,\n      keyboardDismissMode = _this$props.keyboardDismissMode,\n      onScroll = _this$props.onScroll,\n      centerContent = _this$props.centerContent,\n      other = _objectWithoutPropertiesLoose(_this$props, _excluded);\n    if (process.env.NODE_ENV !== 'production' && this.props.style) {\n      var style = StyleSheet.flatten(this.props.style);\n      var childLayoutProps = ['alignItems', 'justifyContent'].filter(prop => style && style[prop] !== undefined);\n      invariant(childLayoutProps.length === 0, \"ScrollView child layout (\" + JSON.stringify(childLayoutProps) + \") \" + 'must be applied through the contentContainerStyle prop.');\n    }\n    var contentSizeChangeProps = {};\n    if (onContentSizeChange) {\n      contentSizeChangeProps = {\n        onLayout: this._handleContentOnLayout\n      };\n    }\n    var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);\n    var children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {\n      var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;\n      if (child != null && (isSticky || pagingEnabled)) {\n        return /*#__PURE__*/React.createElement(View, {\n          style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]\n        }, child);\n      } else {\n        return child;\n      }\n    }) : this.props.children;\n    var contentContainer = /*#__PURE__*/React.createElement(View, _extends({}, contentSizeChangeProps, {\n      children: children,\n      collapsable: false,\n      ref: this._setInnerViewRef,\n      style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]\n    }));\n    var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;\n    var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;\n    var props = _objectSpread(_objectSpread({}, other), {}, {\n      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],\n      onTouchStart: this.scrollResponderHandleTouchStart,\n      onTouchMove: this.scrollResponderHandleTouchMove,\n      onTouchEnd: this.scrollResponderHandleTouchEnd,\n      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,\n      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,\n      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,\n      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,\n      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,\n      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,\n      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,\n      onScroll: this._handleScroll,\n      onResponderGrant: this.scrollResponderHandleResponderGrant,\n      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,\n      onResponderTerminate: this.scrollResponderHandleTerminate,\n      onResponderRelease: this.scrollResponderHandleResponderRelease,\n      onResponderReject: this.scrollResponderHandleResponderReject\n    });\n    var ScrollViewClass = ScrollViewBase;\n    invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');\n    var scrollView = /*#__PURE__*/React.createElement(ScrollViewClass, _extends({}, props, {\n      ref: this._setScrollNodeRef\n    }), contentContainer);\n    if (refreshControl) {\n      return /*#__PURE__*/React.cloneElement(refreshControl, {\n        style: props.style\n      }, scrollView);\n    }\n    return scrollView;\n  }\n}\nvar commonStyle = {\n  flexGrow: 1,\n  flexShrink: 1,\n  // Enable hardware compositing in modern browsers.\n  // Creates a new layer with its own backing surface that can significantly\n  // improve scroll performance.\n  transform: 'translateZ(0)',\n  // iOS native scrolling\n  WebkitOverflowScrolling: 'touch'\n};\nvar styles = StyleSheet.create({\n  baseVertical: _objectSpread(_objectSpread({}, commonStyle), {}, {\n    flexDirection: 'column',\n    overflowX: 'hidden',\n    overflowY: 'auto'\n  }),\n  baseHorizontal: _objectSpread(_objectSpread({}, commonStyle), {}, {\n    flexDirection: 'row',\n    overflowX: 'auto',\n    overflowY: 'hidden'\n  }),\n  contentContainerHorizontal: {\n    flexDirection: 'row'\n  },\n  contentContainerCenterContent: {\n    justifyContent: 'center',\n    flexGrow: 1\n  },\n  stickyHeader: {\n    position: 'sticky',\n    top: 0,\n    zIndex: 10\n  },\n  pagingEnabledHorizontal: {\n    scrollSnapType: 'x mandatory'\n  },\n  pagingEnabledVertical: {\n    scrollSnapType: 'y mandatory'\n  },\n  pagingEnabledChild: {\n    scrollSnapAlign: 'start'\n  }\n});\nvar ForwardedScrollView = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  return /*#__PURE__*/React.createElement(ScrollView, _extends({}, props, {\n    forwardedRef: forwardedRef\n  }));\n});\nForwardedScrollView.displayName = 'ScrollView';\nexport default ForwardedScrollView;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}